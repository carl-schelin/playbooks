#!/usr/bin/ksh

# chkserver - Check the postinstall steps where possible
# Owner: Carl Schelin
# $Id $
# 2013/05/21
# Description: Run through the defined steps to quickly see what might need to be done
#   on a system to complete the installation.
# 2013/05/21 - CS - Fixed spelling on a couple of items. Added check of root's cron if intrado script hasn't been run yet
# 2017/02/21 - CS - Checked in to RCS
# 2017/05/22 - CS - Removed extra interfaces, count interfaces to see if routes need to be checked
# 2017/06/20 - CS - added chkserver.input validation steps.
# 2017/06/22 - CS - Updated to add color and add more things to check
# 2017/06/22 - CS - Updated to check for vmtools installation
# 2017/06/22 - CS - Added color and clean up some of the messages
# 2017/06/26 - CS - write out to .output file like all the others.
# 2017/06/26 - CS - Updated to manage gateways better
# 2017/06/27 - CS - Updated to check all admin default passwords, not just unixsvc
# 2017/06/27 - CS - Updated to show root in the listing
# 2017/06/27 - CS - Updated to fine the right path to the ip command
# 2017/06/29 - CS - Updated the check with grep
# 2017/06/30 - CS - Added subscription manager check, added group membership check
# 2017/06/30 - CS - Fixed typo
# 2017/06/30 - CS - Updated with the correct info
# 2017/06/30 - CS - Remove extra quotes from check
# 2017/06/30 - CS - Fixed the output of grep
# 2017/07/03 - CS - Updated to check for the RemoveIPC value (set to yes; warning)
# 2017/07/03 - CS - Updated to manage colors better (warning, error, and good)
# 2017/07/05 - CS - Updated to fix messages
# 2017/07/05 - CS - Updated to add a security check
# 2017/07/05 - CS - Fixed log info. Fixed data file parse. Updated to check the interface file for Gateway info in addition to the network file
# 2017/07/05 - CS - Updated to change the title and to add the email check for user access
# 2017/07/05 - CS - Updated text
# 2017/07/05 - CS - Updated to add every GATEWAY to the output
# 2017/07/06 - CS - Fix grep output (was displaying emails; add -q to quiet) also added -i to ignore case
# 2017/07/06 - CS - Check for locked account in order to filter messages out
# 2017/07/06 - CS - Add check for Mail Server access
# 2017/07/06 - CS - Added OpNet check
# 2017/07/06 - CS - Update message display
# 2017/07/06 - CS - Add a trailing $ to the IP check to keep from multiple hits due to single digit host IPs
# 2017/07/06 - CS - Updated to add a message for the email check
# 2017/07/10 - CS - Update warning messages with appropriate color
# 2017/07/10 - CS - Added check for access to incojs01
# 2017/07/10 - CS - Added check for time
# 2017/07/11 - CS - Removed private networks from gateway ping test
# 2017/07/11 - CS - updated to ping servers before checking functionality
# 2017/07/13 - CS - Add check of the route table. Just parrot the routetable.output file
# 2017/07/17 - CS - Backup check
# 2017/07/19 - CS - Added user doesn't exist error for users who may not be in the right group
# 2017/07/20 - CS - Moved further app tests from inside the chkserver.input file and out where it executes if it finds the agent
# 2017/07/21 - CS - Added a specific check for bits for nginx
# 2017/07/24 - CS - Added bits for Solaris (need to pull out common bits to functions.
# 2017/07/25 - CS - Updated to properly locate Panorama
# 2017/07/25 - CS - Updated to block out nc checks if netcat isn't found.
# 2017/07/25 - CS - Added status messages for nc to identify when it's stopped.
# 2017/07/25 - CS - Put in more status messages for ping to show where slowdowns are.
# 2017/07/26 - CS - Moving code blocks into functions and updating for different versions where appropriate
# 2017/07/26 - CS - Updated time server check to include seeing if the time servers can sync
# 2017/07/27 - CS - Fixed first/New opnet server access port (443)
# 2017/07/27 - CS - Updated to support HP-UX
# 2017/07/27 - CS - Switch to ksh (need to fix error output)
# 2017/07/28 - CS - Updated so colors work again. Updated to add path info as overnight runs seem to be reporting errors that were corrected
# 2017/07/28 - CS - Updated HP sections for password and expiration dates
# 2017/07/28 - CS - Updated to use dig instead of nslookup with a timeout and outside the ping test
# 2017/07/28 - CS - Updated to check time servers even if ping failed
# 2017/07/31 - CS - Check nsswitch.conf to see if DNS is enabled before doing DNS checks
# 2017/07/31 - CS - fix extra "m" in the backup output
# 2017/07/31 - CS - check ethernet address to see if a vm before checking for vmware tools. if 00:50:56, then VMWare, for now.
# 2017/08/02 - CS - Updated group check to use getent vs parsing the passwd and group files
# 2017/08/02 - CS - Added kubernetes check
# 2017/08/03 - CS - HP-UX doesn't have getent. Add bits to accommodate hp-ux for user capture info
# 2017/08/03 - CS - Updated time check to check to see if it's installed and if it's running before pinging or nc'ing anything
# 2017/08/04 - CS - Fixed chage check for service accounts to just look for 'never'
# 2017/08/04 - CS - Fixed chage again. Trying to get the last item was returning never\n7 for some reason.
# 2017/08/04 - CS - Minor missing $ error
# 2017/08/04 - CS - Update to show service account password that has to be changed
# 2017/08/07 - CS - Added check_log to make sure messages file is being updated
# 2017/08/09 - CS - Updated to make checking the time servers generic (variable and a loop)
# 2017/08/09 - CS - Moved two more code bits into functions.
# 2017/08/09 - CS - Removed extra code and have a single block of 'checkid' type checks before bailing.
# 2017/08/10 - CS - Older Red Hat's didn't like execute ticks within $(( )). Moved Memory check execute out of $(( )) to fix error.
# 2017/08/10 - CS - Updated to support FreeBSDisms plus moving bits around to accommodate FreeBSD.
# 2017/08/14 - CS - Updated the group.master file to add *:or hostname: so updated the check_groupmembership to account for this.
# 2017/08/14 - CS - Replaced all the grep -q with > /dev/null  Erroring out on Sun and probably HP-UX
# 2017/08/15 - CS - Ping on SunOS is ip count where count has to follow ip. HP has -n 2 and works either before or after and Linux has -c 2, same as HP
# 2017/08/15 - CS - Added debugging options
# 2017/08/15 - CS - Fixed netbackup check to look at port in case it's not in /etc/services
# 2017/08/15 - CS - Changed grep of log to only look at the last line (lots of logs in some places and only the last line really matters).
# 2017/08/17 - CS - Updated to report non-standard groups on a system
# 2017/08/21 - CS - Added cron check
# 2017/08/21 - CS - Updated to check files on different OSs (different locations)
# 2017/08/22 - CS - Add check for centrify to add more groups to the check script.
# 2017/08/22 - CS - Updated group loop check to use getent to determine if a group exists on the system
# 2017/08/23 - CS - Updated group_membership to properly check for users not in the right group when checking a specific host vs any host via * or ?
# 2017/08/24 - CS - Added check_disk_suite to check the status of SDS
# 2017/08/24 - CS - Added check_interfaces to check for FAILED interfaces
# 2017/09/05 - CS - Removed the hosts.allow issues as unneeded for Netbackup any more.
# 2017/09/05 - CS - Fixed group.master check.
# 2017/09/05 - CS - Added a check_lsof function to identify deleted logs
# 2017/09/11 - CS - Updated netbackup to check hosts.allow but only on nb 6 clients (55 as of last count)
# 2017/09/11 - CS - Check for swap space; limited right now but will expand as we progress
# 2017/09/14 - CS - fix metadb check to only check the first 20 characters due to drive names with caps
# 2017/09/19 - CS - Updated to exclude checks due to them being acceptible
# 2017/09/26 - CS - Added memory exclude check for servers with a large amount of ram.
# 2017/09/27 - CS - Added nrpe (Nagios) check function
# 2017/09/27 - CS - Updated time to check the config file and properly check or display error if unable
# 2017/09/28 - CS - Increased debugging and add more debugging inside functions where added
# 2017/09/29 - CS - Increased debugging info again
# 2017/10/02 - CS - Updated check_sudoers to verify group entries in the sudoers file exist on the system
# 2017/10/02 - CS - Updated check_group to check for a centrify group
# 2017/10/21 - CS - Fix hosts.allow check to permit spaces
# 2017/10/21 - CS - Added check_cpus
# 2017/10/21 - CS - Added check_addresses
# 2017/10/24 - CS - Reorder time check to avoid extra unnecessary errors
# 2017/10/24 - CS - Some ntpdate checks fail even though ntp is working. Put the check back in but still in a reverse order
# 2017/10/30 - CS - Added check_selinux to check selinux status
# 2017/11/06 - CS - Added check_techops to check to see if the directory exists.
# 2017/11/06 - CS - Added a commented "number of checks" to be able to calculate totals.
# 2017/11/06 - CS - Updated openview check to add a certificate check
# 2017/11/07 - CS - Updated openview check to add the number of running and aborted processes and to check for buffering
# 2017/11/07 - CS - Updated openview check to add stopped and starting to the list
# 2017/11/10 - CS - Added bbcutil check of Openview. Removed /dev/null redirect as I'm printing a bunch of text anyway.
# 2017/11/13 - CS - Added openview configuration check
# 2017/11/15 - CS - Added disk space check
# 2017/11/16 - CS - Updated check_openview route check to accurately identify route information
# 2017/11/16 - CS - Added a check_management_route function and added it to all the functions where we're looking for access
# 2017/11/16 - CS - Updated the satellite check to ping and netcat check ports
# 2017/12/02 - CS - Added a check for oom-killer messages
# 2017/12/02 - CS - check for katello-ca certificate rpm and katello-agent agent rpm installations
# 2017/12/02 - CS - Update to check management routes for netbackup
# 2017/12/02 - CS - Update to check access to specific netbackup ports
# 2017/12/03 - CS - Only check for Katello if system is or was subscribed
# 2017/12/03 - CS - Updated check_openview to confirm denied request for a certificate
# 2017/12/10 - CS - Check for active ctrl-alt-del flag but only on VMs.
# 2017/12/10 - CS - Check to see if remote root access is permitted; leveraging etc/chksecurity.output
# 2017/12/27 - CS - Updated management interface check; if on the same network it fails
# 2017/12/27 - CS - Brought IPs and servers to the top to make managing listing easier; added loops in case more than one is added

VERSION="chkserver v1.191"
PROGNAME="chkserver"
HOSTNAME=`hostname|cut -f1 -d.`
COUNT=0
GATEWAY=''
GWFLAG='no'
GWMSG=''
OS=`uname`
CENTRIFY='no'
GREEN="\033[32m"
RED="\033[31m"
YELLOW="\033[33m"
RESET="\033[0m"
INTRADO=/opt/intrado
LOG=$INTRADO/etc/chkserver.output
SEVEN=$(( 86400 * 7 ))
PATH=/bin:/usr/bin:/sbin:/usr/sbin:/opt/csw/bin:/usr/contrib/bin; export PATH
GPSSERVERS="10.100.228.31 192.168.200.20"
MONSERVERS="Longmont:10.109.243.19 Miami:10.109.226.19"
NBSERVERS="10.100.6.25 10.32.138.14"
BUSERVERS="inveri01-gig0 10.100.6.25 inveri02 10.32.138.14 incobu01 10.100.77.77 incobu02 10.100.5.89"
BUEXTRA="incobu03 10.100.128.141 lmntcoecmma10 10.109.30.22"
BUIPLIST="10.100.6.25 10.32.138.14 10.100.77.77 10.100.5.89 10.100.128.141 10.109.30.22"
DPSERVERS="10.100.128.3"
EMAILSERVERS="10.100.104.6"
MGTSERVERS="10.100.78.143 10.100.128.149 192.168.208.86 10.100.128.201"
MGTLISTING="incojs01.scc911.com:10.100.78.143 lnmt1cuomtool11.scc911.com:10.100.128.149 miam1cuomtool11.scc911.com:192.168.208.86 inventory.scc911.com:10.100.128.201"
OPNETSERVERS="10.32.10.1:443 10.100.4.63:19090 10.100.4.64:19090"
SATELLITESERVERS="10.100.143.51"

OSMAJOR=0
if [[ -f /etc/redhat-release ]]
then
  OUTPUT=`grep 'release 7' /etc/redhat-release`
  if [[ ! -z $OUTPUT ]]
  then
    OSMAJOR=7
  fi
  OUTPUT=`grep 'release 6' /etc/redhat-release`
  if [[ ! -z $OUTPUT ]]
  then
    OSMAJOR=6
  fi
  OUTPUT=`grep 'release 5' /etc/redhat-release`
  if [[ ! -z $OUTPUT ]]
  then
    OSMAJOR=5
  fi
fi

# enable debugging
DEBUG='0'
if [[ ! -z $1 ]]
then
  if [[ $1 = 'debug' ]]
  then
    DEBUG="$2"
  fi
fi

if [[ -f $LOG ]]
then
  rm $LOG
fi

# the sun nc doesn't handle -w wait flag well so we'll blank it if something's passed on the command line
if [[ $OS = 'SunOS' ]] && [[ ! -z $1 ]]
then
  NETCAT=''
else
  NETCAT='nc'
fi

# The ping count flags are different on the three OSs'
# location of cron.allow and cron.deny are different

PINGCT="-c 1"
CRONALLOW="/etc/cron.allow"
CRONDENY="/etc/cron.deny"
if [[ $OS = "SunOS" ]]
then
  PINGCT="2"
  CRONALLOW="/etc/cron.d/cron.allow"
  CRONDENY="/etc/cron.d/cron.deny"
fi
if [[ $OS = 'HP-UX' ]]
then
  PINGCT="-n 2"
  CRONALLOW="/var/adm/cron/cron.allow"
  CRONDENY="/var/adm/cron/cron.deny"
fi

# sun freeware install
if [[ -f /opt/sfw/etc/sudoers ]]
then
  SUDOERS='/opt/sfw/etc/sudoers'
fi

# defualt installation of sudoers
if [[ -f /etc/sudoers ]]
then
  SUDOERS='/etc/sudoers'
fi

# intrado custom install
if [[ -f /usr/local/etc/sudoers ]]
then
  SUDOERS='/usr/local/etc/sudoers'
fi

# hp-ux location
if [[ -f /opt/iexpress/sudo/etc/sudoers ]]
then
  SUDOERS='/opt/iexpress/sudo/etc/sudoers'
fi


######################
### Return the epoch
######################

#Get date values of the date to be converted for second, minute, hour, day, month, year.
#day=(year*365)+(year/4)-(year/100)+(year/400)+(month*306001/10000)+day
#days_since_epoch=day-719591 (which is Jan 1 1970)
#seconds_since_epoch=(days_since_epoch*86400)+(hour*3600)+(minute*60)+seconds

epoch() {
  EP_YEAR=$1
  EP_MONTH=$2
  EP_DAY=$3

  if [[ $OS = 'SunOS' ]]
  then
    NUMBER_DAYS=$(( $EP_YEAR * 365 ))
    LEAP_YEARS=$(( $EP_YEAR / 4 ))
    LEAP_CENTURY=$(( $EP_YEAR / 100 ))
    LEAP_CENTURIES=$(( $EP_YEAR / 400 ))
    DAYS_IN_MONTH=$(( $EP_MONTH * 306001 / 10000 ))
    EXPIRE=$(( ( $NUMBER_DAYS + $LEAP_YEARS - $LEAP_CENTURY + $LEAP_CENTURIES + $DAYS_IN_MONTH + $EP_DAY ) * 86400 ))
  fi

  echo $EXPIRE
}

EPYEAR=`date +"%Y"`
EPMONTH=`date +"%m"`
EPDAY=`date +"%d"`
EPOCH=`epoch $EPYEAR $EPMONTH $EPDAY`


######################
### Check the Management Interface for the passed Destination IP Address
### Management traffic, openview, opnet, data palette, netbackup, etc goes out the management interface.
### This function checks that.
######################

check_management_route() {
  IPADDRESS=$1

  MANAGEMENT_INTERFACE=`grep "^${HOSTNAME}:InterfaceMonitored:" ${INTRADO}/etc/chkserver.input | cut -f3 -d:`

  if [[ ${MANAGEMENT_INTERFACE} = '' ]]
  then
    printf "%b\n" "    ${RED}Unable to locate ${HOSTNAME} in chkserver.input file to verify Route Configuration${RESET}" >> $LOG
  else
# just checking for Linux now
    if [[ ${OS} = "Linux" ]]
    then
      if [[ -f /sbin/ip ]] || [[ -f /bin/ip ]]
      then

        ROUTE=`ip route get ${IPADDRESS} | head -1 | awk '{print $5}'`
        if [[ ${ROUTE} = ${MANAGEMENT_INTERFACE} ]]
        then
          printf "%b\n" "    ${GREEN}Route to ${IPADDRESS} is correct.${RESET}" >> $LOG
        else
# if on the same network; the 'via' is missing so only get the 3rd item which is the device
          ROUTE=`ip route get ${IPADDRESS} | head -1 | awk '{print $3}'`
          if [[ ${ROUTE} = ${MANAGEMENT_INTERFACE} ]]
          then
            printf "%b\n" "    ${GREEN}Route to ${IPADDRESS} is correct.${RESET}" >> $LOG
          else
            printf "%b\n" "    ${YELLOW}Route to ${IPADDRESS} missing.${RESET}" >> $LOG
          fi
        fi

      else

        ROUTE=`netstat -rn | egrep "^${IPADDRESS}.*${EXPECTED_INTERFACE}"`
        if [[ -z ${ROUTE} ]]
        then
          printf "%b\n" "    ${GREEN}Route to ${IPADDRESS} is correct.${RESET}" >> $LOG
        else
          printf "%b\n" "    ${YELLOW}Route to ${IPADDRESS} missing.${RESET}" >> $LOG
        fi
      fi
    fi
  fi
}



###################################
### Functions:
###   Note that functions are in alphabetical order where defined here but in logical, checkbox order in the OS specific check areas
###################################


######################
### Check to make sure employees haven't departed (accounts need to be locked)
### Number of Checks: [Number of users on the system]
######################

check_active_employees() {
# active employee check
# loop through the users on a system
# exclude users in the users.exclude file
# exclude locked users
# once passes, check gecos field for email
# check intrado.email for email
# report error if it doesn't exist.
# found == 0
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_active_employees(1)"
  fi
  if [[ -f $INTRADO/etc/chksudo.dat ]]
  then
    printf "%b\n" "  ${GREEN}Active employee verification${RESET}" >> $LOG
    for j in `cut -f1 -d: /etc/passwd`
    do
      grep -i "^${j}$" $INTRADO/etc/users.exclude > /dev/null
      if [[ $? = 1 ]]
      then

        LOCKED=''
        if [[ ${OS} = 'Linux' ]]
        then
          LOCKED=`passwd -S ${j} | awk '{print $2}'`
          if [[ ${LOCKED} = "L" ]] || [[ ${LOCKED} = 'locked.' ]]
          then
            LOCKED="LK"
          fi
        else
          if [[ ${OS} = 'HP-UX' ]]
          then
# is the system "TRUSTED"?
            if [[ -f "/tcb/files/auth/system/default" ]]
            then
              LOCKED=`/usr/lbin/getprpw -m alock ${j}`
              if [[ ${LOCKED} = "alock=YES" ]]
              then
                LOCKED="LK"
              fi
            fi
          else
            if [[ ${OS} = 'FreeBSD' ]]
            then
              LOCKED=`grep ${j} /etc/master.passwd | grep "*LOCKED*"`
              if [[ ! -z ${LOCKED} ]]
              then
                LOCKED="LK"
              fi
            else
              LOCKED=`passwd -s ${j} | awk '{print $2}'`
            fi
          fi
        fi

        if [[ ! $LOCKED = 'LK' ]]
        then
          EMAIL=`grep "^${j}:" /etc/passwd | cut -f5 -d: | cut -f2 -d,`
          if [[ ! -z $EMAIL ]]
          then
            grep -i "^${EMAIL}$" $INTRADO/etc/intrado.email > /dev/null
            if [[ $? = 1 ]]
            then
              printf "%b\n" "    ${RED}${j}/${EMAIL} was not found in the /opt/intrado/etc/intrado.email file and the account isn't locked.${RESET}" >> $LOG
            fi
          fi
        fi
      fi
    done
  fi
  if [[ ${DEBUG} = '1' ]]
  then
    echo "Exiting check_active_employees()"
  fi
}


######################
### Check assigned IP addresses
### Number of Checks: 4 * [Number of interfaces] + 1
######################

check_addresses() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering IP check"
  fi
  if [[ $OS = 'Linux' ]]
  then
    OUTPUT=`ip addr | grep " ${FIELD3}/"`
  fi
  if [[ ! -z $OUTPUT ]]
  then
    INTERFACE=`egrep "(\"|)${FIELD3}(\"|)$" /etc/sysconfig/network-scripts/ifcfg-* | cut -f1 -d: | cut -f3 -d-`
    printf "%b\n" "  ${GREEN}IP $FIELD3 configured as ${INTERFACE}${RESET}" >> $LOG
    egrep -i "onboot.*yes" /etc/sysconfig/network-scripts/ifcfg-${INTERFACE} > /dev/null
    if [[ $? = 0 ]]
    then
      printf "%b\n" "    ${GREEN}${INTERFACE} is configured to start on boot${RESET}" >> $LOG
    else
      printf "%b\n" "    ${RED}${INTERFACE} is not configured to start on boot${RESET}" >> $LOG
    fi
    grep -i ${FIELD3} /etc/hosts > /dev/null
    if [[ $? = 1 ]]
    then
      printf "%b\n" "    ${YELLOW}${FIELD3} is not in /etc/hosts${RESET}" >> $LOG
    fi
    PRIVATE=`ipcalc -n ${FIELD4}/24 | cut -f2 -d=`
    if [[ ${PRIVATE} = '192.168.0.0' ]]
    then
    printf "%b\n" "    ${GREEN}Gateway ${FIELD4} is on a Private network${RESET}" >> $LOG
    else
      echo "  ping check of the gateway: ${FIELD4}"
      ping ${FIELD4} ${PINGCT} > /dev/null
      if [[ $? = 0 ]]
      then
        printf "%b\n" "    ${GREEN}Gateway ${FIELD4} accessible${RESET}" >> $LOG
      else
        printf "%b\n" "    ${RED}Gateway ${FIELD4} is not responding to ping${RESET}" >> $LOG
      fi
    fi
    GATEWAY="${GATEWAY} ${FIELD4}"
    grep "GATEWAY=${FIELD4}" /etc/sysconfig/network > /dev/null
    if [[ $? = 0 ]]
    then
      GWMSG="${GWMSG}    ${GREEN}/etc/sysconfig/network:GATEWAY=${FIELD4} configured${RESET}\n"
      GWFLAG='yes'
    fi
# check the interface file too
    grep "GATEWAY=${FIELD4}" /etc/sysconfig/network-scripts/ifcfg-${INTERFACE} > /dev/null
    if [[ $? = 0 ]]
    then
      GWMSG="${GWMSG}    ${GREEN}/etc/sysconfig/network-scripts/ifcfg-${INTERFACE}:GATEWAY=${FIELD4} configured${RESET}\n"
      GWFLAG='yes'
    fi
  else
    printf "%b\n" "  ${RED}Unable to locate ${FIELD3} in ip addr output${RESET}" >> $LOG
  fi
}


######################
### Check Centrify if installed
### Number of Checks: 3
######################

check_centrify() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_centrify(2)"
  fi
  if [[ -f /usr/sbin/adclient ]]
  then
    printf "%b\n" "  ${GREEN}Centrify is installed${RESET}" >> $LOG
    CENTRIFY=`ps -e | grep adclient`
    if [[ ! -z $CENTRIFY ]]
    then
      printf "%b\n" "    ${GREEN}Centrify is running${RESET}" >> $LOG
      /usr/bin/adinfo
      if [[ $? = 0 ]]
      then
        CENTRIFY='yes'
#[root@cofmcc1 bin]# adinfo
#Local host name:   cofmcc1
#Joined to domain:  unix.intrado.pri
#Joined as:         cofmcc1.unix.intrado.pri
#Pre-win2K name:    cofmcc1
#Current DC:        lmv08-udc01.unix.intrado.pri
#Preferred site:    LGMT-CO
#Zone:              unix.intrado.pri/Unix/Zones/FMCC
#Last password set: 2017-07-14 15:47:36 MDT
#CentrifyDC mode:   connected
#Licensed Features: Enabled
        ADDOMAIN=`/usr/bin/adinfo | awk '/Joined to domain:/{print $4}'`
        printf "%b\n" "    ${GREEN}Centrify is connected to ${ADDOMAIN}${RESET}" >> $LOG
      fi
#Linux:cschelin@infltx10$ adinfo
#Not joined to any domain
#Licensed Features: Enabled
#Linux:cschelin@infltx10$ echo $?
#10
      /usr/bin/adinfo
      if [[ $? = 10 ]]
      then
        printf "%b\n" "    ${RED}Centrify is not connected${RESET}" >> $LOG
      fi
    else
      printf "%b\n" "    ${YELLOW}Centrify is not running${RESET}" >> $LOG
    fi
  fi
  if [[ ${DEBUG} = '2' ]]
  then
    echo "Exiting check_centrify()"
  fi
}


######################
### Check the status of cfg2html
### Number of Checks: 2
######################

check_cfg2html() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_cfg2html(28)"
  fi
  if [[ ! -d /opt/intrado/cfghtml ]]
  then
    printf "%b\n" "  ${YELLOW}cfg2html not installed${RESET}" >> $LOG
  else
    if [[ ! -f /opt/intrado/cfghtml/$HOSTNAME.html ]]
    then
      printf "%b\n" "  ${RED}cfg2html has not been run${RESET}" >> $LOG
    fi
  fi
  if [[ ${DEBUG} = '28' ]]
  then
    echo "Exiting check_cfg2html()"
  fi
}


######################
### Check the number of CPUs against what's requested
### Number of Checks: 1
######################

check_cpus() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering CPU check"
  fi
  COUNT=`grep -c processor /proc/cpuinfo`
  if [[ $COUNT -ne $FIELD3 ]]
  then
    printf "%b\n" "  ${RED}System shows $COUNT CPUs where expected is $FIELD3 CPUs${RESET}" >> $LOG
  else
    printf "%b\n" "  ${GREEN}$COUNT CPUs as expected${RESET}" >> $LOG
  fi
}


######################
### Check Data Palette if installed
### Number of Checks: 3
######################

check_data_palette() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_data_palette(3)"
  fi
  if [[ -f /opt/datapalette/bin/datapal ]]
  then
    printf "%b\n" "  ${GREEN}Data Palette is installed${RESET}" >> $LOG
    DPPS=`ps -e | grep datapal`
    if [[ ! -z $DPPS ]]
    then
      printf "%b\n" "    ${GREEN}Data Palette is running${RESET}" >> $LOG
    else
      printf "%b\n" "    ${RED}Data Palette is not running${RESET}" >> $LOG
    fi
    for i in $DPSERVERS
    do
      check_management_route ${i}
      echo "  ping check of data palette nerve center: ${i}"
      ping ${i} ${PINGCT} > /dev/null
      if [[ $? = 0 ]]
      then
        printf "%b\n" "    ${GREEN}Data Palette Nerve Center ${i} is pingable${RESET}" >> $LOG
        if [[ ! -z ${NETCAT} ]]
        then
          echo "  nc check of Data Palette Nerve Center ${i}"
          echo "quit" | ${NETCAT} -w 2 -vn ${i} 8080 > /dev/null 2>&1
          if [[ $? = 0 ]]
          then
            printf "%b\n" "    ${GREEN}Data Palette Nerve Center (${i}:8080) is accessible${RESET}" >> $LOG
          else
            printf "%b\n" "    ${RED}Data Palette Nerve Center (${i}:8080) is not accessible${RESET}" >> $LOG
          fi
        fi
      else
        printf "%b\n" "    ${RED}Data Palette Nerve Center ${i} is not pingable${RESET}" >> $LOG
      fi
    done
  fi
  if [[ ${DEBUG} = '3' ]]
  then
    echo "Exiting check_data_palette()"
  fi
}


######################
### Check default installation passwords
### Number of Checks: 2 + [Number of Sysadmins]
######################

check_default_passwords() {
# check the password against the kickstart default
# leave root and all the admins in the listing, even the ones that are gone, as they may still be set to default
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_default_passwords(4)"
  fi
  printf "%b\n" "  ${GREEN}Account password verification${RESET}" >> $LOG
  for j in root cschelin kzupan jnoyes tcooper escott mchahud jschroet jmetz ppietras unixsvc
  do
    UNIXDEF='$1$YDorwFsD$0/fIFtn7YZhMvZjAUZ.V./'

# hp-ux; get the first character of the user name
# then go to /tcb/files/auth/[userchar]/username
# grep :u_pwd=, cut on colon and equal to get unixpw
# since it's not a kickstart, it's unlikely to be set on HP or Solaris systems
    UNIXPW=""
    if [[ $OS = 'HP-UX' ]]
    then
      FIRSTCHAR=`echo $j | cut -c1`
      if [[ -f /tcb/files/auth/${FIRSTCHAR}/${j} ]]
      then
        UNIXPW=`grep ":u_pwd=${UNIXDEF}$" /tcb/files/auth/${FIRSTCHAR}/${j}`
      fi
    else
      if [[ $OS = 'FreeBSD' ]]
      then
        UNIXPW=`grep "^${j}:" /etc/master.passwd | grep ":${UNIXDEF}:"`
      else
        UNIXPW=`grep "^${j}:" /etc/shadow | grep ":${UNIXDEF}:"`
      fi
    fi
    if [[ ! -z $UNIXPW ]]
    then
      printf "%b\n" "    ${RED}${j} account password is still set to the default${RESET}" >> $LOG
    fi
  done
  if [[ ${DEBUG} = '4' ]]
  then
    echo "Exiting check_default_passwords()"
  fi
}


######################
### Check disk space
### Number of Checks: 2
######################

check_disk_space() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_disk_space(31)"
  fi

  printf "%b\n" "  ${GREEN}Checking disk space${RESET}" >> $LOG
  DISKSPACE=${INTRADO}/etc/diskspace.output
  if [[ $OS = "HP-UX" ]]
  then
    bdf -l > ${DISKSPACE}
  fi
  if [[ $OS = "Linux" ]]
  then
    df -klP > ${DISKSPACE}
  fi
  if [[ $OS = "SunOS" ]]
  then
    df -kl > ${DISKSPACE}
  fi
  if [[ $OS = "FreeBSD" ]]
  then
    df -kl > ${DISKSPACE}
  fi

  for j in `egrep "^(/dev|all_space|cloifs_pool|diskpool|rpool|sanpool|space|syslog_local|syslog_san)/" ${DISKSPACE} | egrep -v "^(/dev/loop)" | awk '{print $NF":"$5}'`
  do
    FILESYSTEM=`echo $j | cut -f1 -d:`
    SPACE=`echo $j | cut -f2 -d: | cut -f1 -d%`
    WARNING=85
    ERROR=95

    if [[ $SPACE -ge $ERROR ]]
    then
      printf "%b\n" "    ${RED}${FILESYSTEM} has reached or exceeded 95% (${SPACE})%${RESET}" >> $LOG
    else
      if [[ $SPACE -ge $WARNING ]]
      then
        printf "%b\n" "    ${YELLOW}${FILESYSTEM} has reached or exceeded 85% (${SPACE})%${RESET}" >> $LOG
      fi
    fi
  done
  if [[ ${DEBUG} = '31' ]]
  then
    echo "Exiting check_disk_space()"
  fi
}


######################
### Check the health of Solaris Disk Suite
### Number of Checks: 2
######################

check_disk_suite() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_disk_suite(5)"
  fi

  if [[ -f /usr/sbin/metadb ]] && [[ -f /usr/sbin/metastat ]]
  then
    printf "%b\n" "  ${GREEN}Checking Solaris Disk Suite.${RESET}" >> $LOG

    OUTPUT=`metadb | awk '/[WMDFSR]/{print $NF;exit}'`
    if [[ ! -z $OUTPUT ]]
    then
      printf "%b\n" "    ${RED}Disk Suite metadb error on ${OUTPUT}.${RESET} /usr/sbin/metadb" >> $LOG
    fi

    OUTPUT=`metastat | awk '/metareplace/{print $3,$4;exit}'`
    if [[ ! -z $OUTPUT ]]
    then
      printf "%b\n" "    ${RED}Disk Suite metastat error on ${OUTPUT}.${RESET} /usr/sbin/metastat" >> $LOG
    fi
  fi
  if [[ ${DEBUG} = '5' ]]
  then
    echo "Exiting check_disk_suite()"
  fi
}


######################
### Check access to the mail server
### Number of Checks: 2
######################

check_email() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_email(32)"
  fi
  for i in ${EMAILSERVERS}
  do
    printf "%b\n" "  ${GREEN}Checking mail server (${i}:25)${RESET}" >> $LOG
    check_management_route ${i}
    echo "  ping check of mail server: ${i}"
    ping ${i} ${PINGCT} > /dev/null
    if [[ $? = 0 ]]
    then
      printf "%b\n" "    ${GREEN}Email server ${i} is pingable${RESET}" >> $LOG
      if [[ ! -z ${NETCAT} ]]
      then
        echo "  nc check of Mail Server ${i}"
        echo "quit" | ${NETCAT} -w 2 -vn ${i} 25 > /dev/null 2>&1
        if [[ $? = 0 ]]
        then
          printf "%b\n" "    ${GREEN}Email server (${i}:25) is accessible${RESET}" >> $LOG
        else
          printf "%b\n" "    ${RED}Email server (${i}:25) is not accessible${RESET}" >> $LOG
        fi
      fi
    else
      printf "%b\n" "    ${RED}Email server {$i} is not pingable${RESET}" >> $LOG
    fi
  done
  if [[ ${DEBUG} = '32' ]]
  then
    echo "Exiting check_email()"
  fi
}


######################
### Check group memberships
### Number of Checks: 5 * [Number of users on the system]
######################

# todo: check for centrify to be installed
# need to check groups and if centrify, check centrify groups
# need to get group id and check passwd as well
# 

check_group_membership() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_group_membership(6)"
  fi
  printf "%b\n" "  ${GREEN}Group membership verification${RESET}" >> $LOG

  GROUPLIST=`cut -f1 -d: /etc/group`
  if [[ ${CENTRIFY} = 'yes' ]]
  then
    GROUPLIST="${GROUPLIST} `adquery group | cut -f1 -d:`"
  fi

# check all system groups to see if they're in the group.master file
  for i in ${GROUPLIST}
  do
# look for the hostname first then see if the system is centrified, otherwise check all servers
    GROUP=`grep -v "^#" ${INTRADO}/etc/group.master | grep -i "^${HOSTNAME}:${i}:" | cut -f3 -d: | sed -e "s/,/ /g"`
    if [[ -z ${GROUP} ]]
    then
      if [[ ${CENTRIFY} = 'yes' ]]
      then
        GROUP=`grep -v "^#" ${INTRADO}/etc/group.master | grep -i "^centrify:${i}:" | cut -f3 -d: | sed -e "s/,/ /g"`
      else
        GROUP=`grep -v "^#" ${INTRADO}/etc/group.master | grep -i "^\*:${i}:" | cut -f3 -d: | sed -e "s/,/ /g"`
      fi
# check non-standard groups if not found
      if [[ -z ${GROUP} ]]
      then
        GROUP=`grep -v "^#" ${INTRADO}/etc/group.master | grep -i "^\?:${i}:" | cut -f3 -d: | sed -e "s/,/ /g"`
        if [[ ! -z ${GROUP} ]]
        then
          printf "%b\n" "    ${RED}${i} is a non-standard group and needs to be corrected${RESET}" >> $LOG
        fi
      fi
    fi

    if [[ ! -z ${GROUP} ]]
    then
# found the group in the group.master file. Now check all users in group.master list against /etc/group list and throw an error if not found
      for j in ${GROUP}
      do
        if [[ $OS = 'HP-UX' ]] || [[ $OS = 'FreeBSD' ]]
        then
          grep -i "^${j}:" /etc/passwd > /dev/null
          if [[ $? = 1 ]]
          then
            printf "%b\n" "    ${RED}${j} does not have a login on this system${RESET}" >> $LOG
          fi
          egrep -i "^${i}.*(:|,)${j}(,|$)" /etc/group > /dev/null
          if [[ $? = 1 ]]
          then
            printf "%b\n" "    ${RED}${j} was not found in the ${i} group in /etc/group${RESET}" >> $LOG
          fi
        else
# getent will pull from whatever database is in place; on board, idm, or centrify
          getent passwd ${j} > /dev/null
          if [[ $? -ne 0 ]]
          then
            printf "%b\n" "    ${RED}${j} does not have a login on this system${RESET}" >> $LOG
          fi
          getent group ${i} | egrep "(:|,)${j}(,|$)" > /dev/null
          if [[ $? -ne 0 ]]
          then
            printf "%b\n" "    ${RED}${j} was not found in the ${i} group${RESET}" >> $LOG
          fi
        fi
      done

# now check all users in /etc/group against group.master and throw an error if found
      if [[ $OS = 'HP-UX' ]] || [[ $OS = 'FreeBSD' ]]
      then
        USERLIST=`grep "^${i}:" /etc/group | cut -f4 -d: | sed -e "s/,/ /g"`
      else
        USERLIST=`getent group ${i} | cut -f4 -d: | sed -e "s/,/ /g"` > /dev/null
      fi

      for j in ${USERLIST}
      do
# look for the hostname first, if not found, then check the centrify flag and * if not centrified, then check the questionable groups
        GRPFND=`grep -v "^#" ${INTRADO}/etc/group.master | grep -i "^${HOSTNAME}:${i}:"`
        if [[ -z ${GRPFND} ]]
        then
          if [[ ${CENTRIFY} = 'yes' ]]
          then
            GRPFND=`grep -v "^#" ${INTRADO}/etc/group.master | grep -i "^centrify:${i}:"`
          else
            GRPFND=`grep -v "^#" ${INTRADO}/etc/group.master | grep -i "^\*:${i}:"`
          fi
          if [[ -z ${GRPFND} ]]
          then
            GRPFND=`grep -v "^#" ${INTRADO}/etc/group.master | grep -i "^\?:${i}:"`
            if [[ ! -z ${GRPFND} ]]
            then
              PRESENT=`grep -v "^#" ${INTRADO}/etc/group.master | egrep -i "^\?:${i}:" | egrep -i "(:|,)${j}(,|$)"`
              FOUND="?:${i}"
            fi
          else
            if [[ ${CENTRIFY} = 'yes' ]]
            then
              PRESENT=`grep -v "^#" ${INTRADO}/etc/group.master | egrep -i "^centrify:${i}:" | egrep -i "(:|,)${j}(,|$)"`
              FOUND="centrify:${i}"
            else
              PRESENT=`grep -v "^#" ${INTRADO}/etc/group.master | egrep -i "^\*:${i}:" | egrep -i "(:|,)${j}(,|$)"`
              FOUND="*:${i}"
            fi
          fi
        else
          PRESENT=`grep -v "^#" ${INTRADO}/etc/group.master | egrep -i "^${HOSTNAME}:${i}:" | egrep -i "(:|,)${j}(,|$)"`
          FOUND="${HOSTNAME}:${i}"
        fi

# if the user wasn't found in the group.master list for the host, * or ? config, call it out.
        if [[ -z ${PRESENT} ]]
        then
          printf "%b\n" "    ${RED}${j} was found in the ${i} group but not in ${FOUND} in group.master${RESET}" >> $LOG
        fi
      done
    fi
  done
  if [[ ${DEBUG} = '6' ]]
  then
    echo "Exiting check_group_membership()"
  fi
}


######################
### Check the hostname
### Number of Checks: 1
######################

check_hostname() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_hostname(7)"
  fi
  HOSTNAME=`hostname|cut -f1 -d.`
  grep -i ${HOSTNAME} /etc/hosts > /dev/null
  if [[ $? = 0 ]]
  then
    printf "%b\n" "  ${GREEN}${HOSTNAME} is in /etc/hosts${RESET}" >> $LOG
  else
    printf "%b\n" "  ${YELLOW}${HOSTNAME} not in /etc/hosts${RESET}" >> $LOG
  fi
}


######################
### Check interfaces for status
### Number of Checks: 1
######################

check_interfaces() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_interfaces(33)"
  fi
  printf "%b\n" "  ${GREEN}Checking Network Interfaces${RESET}" >> $LOG
  if [[ $OS = 'SunOS' ]]
  then
    OUTPUT=`ifconfig -a | grep FAILED`
  fi
  if [[ $OS = 'Linux' ]]
  then
    OUTPUT=`ifconfig | grep FAILED`
  fi
  if [[ $OS = 'HP-UX' ]]
  then
    OUTPUT=''
    for i in `lanscan | grep lan | awk '{print $5}'`
    do
      OUTPUT="${OUTPUT}`ifconfig $i | grep FAILED`"
    done
  fi
  if [[ $OS = 'FreeBSD' ]]
  then
    OUTPUT=`ifconfig | grep FAILED`
  fi

  if [[ ! -z ${OUTPUT} ]]
  then
    printf "%b\n" "    ${RED}Failed Interface found.${RESET}" >> $LOG
  fi
  if [[ ${DEBUG} = '33' ]]
  then
    echo "Exiting check_interfaces()"
  fi
}


######################
### Check to make sure intrado scripts have run
### Number of Checks: 2
######################

check_intrado() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_intrado(8)"
  fi
  if [[ ! -f /opt/intrado/var/intrado.log ]]
  then
    printf "%b\n" "  ${YELLOW}The /opt/intrado/bin/intrado script hasn't run yet.${RESET}" >> $LOG
  fi
  CRON=`crontab -l | grep -v "^#" | grep "/opt/intrado/bin/intrado"`
  if [[ -z $CRON ]]
  then
    printf "%b\n" "  ${RED}The intrado script is disabled in root's cron${RESET}" >> $LOG
  fi
  if [[ ${DEBUG} = '8' ]]
  then
    echo "Exiting check_intrado()"
  fi
}


######################
### Check access to the Jumpstart web site
### Number of Checks: 2
######################

check_jumpstart() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_jumpstart(9)"
  fi
  for i in ${MGTSERVERS}
  do
    printf "%b\n" "  ${GREEN}Checking management server (${i}:80)${RESET}" >> $LOG
    check_management_route ${i}
    echo "  ping check of management server: ${i}"
    ping ${i} ${PINGCT} > /dev/null
    if [[ $? = 0 ]]
    then
      printf "%b\n" "    ${GREEN}Management server ${i} is pingable${RESET}" >> $LOG
      if [[ ! -z ${NETCAT} ]]
      then
        echo "  nc check of Management Server ${i}"
        echo "\n\n" | ${NETCAT} -w 2 -vn ${i} 80 > /dev/null 2>&1
        if [[ $? = 0 ]]
        then
          printf "%b\n" "    ${GREEN}Management server ${i} is accessible${RESET}" >> $LOG
        else
          printf "%b\n" "    ${RED}Management server ${i} is not accessible${RESET}" >> $LOG
        fi
      fi
    else
      printf "%b\n" "    ${RED}Management server ${i} is not pingable${RESET}" >> $LOG
    fi
  done
  if [[ ${DEBUG} = '9' ]]
  then
    echo "Exiting check_jumpstart()"
  fi
}


######################
### Check to make sure ksh is linked. On RH7, ksh is in /bin vs /usr/bin as it is on every other system.
### Number of Checks: 1
######################

check_ksh() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_ksh(10)"
  fi
  if [[ $OS = 'Linux' ]]
  then
    if [[ ! -f /usr/bin/ksh ]]
    then
      printf "%b\n" "  ${RED}Need to create a symbolic link between /bin/ksh and /usr/bin/ksh${RESET}" >> $LOG
    fi
  fi
  if [[ ${DEBUG} = '10' ]]
  then
    echo "Exiting check_ksh()"
  fi
}


######################
### Check the status of running pods
### Number of Checks: 2 * [Number of Containers to check]
######################

check_kubernetes() {
# enumerate namespaces to see what's running on the server.
# then get the number of processes and report any containers that aren't fully running
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_kubernetes(11)"
  fi
  if [[ -f /bin/kubectl ]]
  then
    printf "%b\n" "  ${GREEN}Checking Kubernetes Container status${RESET}" >> $LOG
    for i in `kubectl get namespaces | grep Active | egrep -v "(NAME|default)"`
    do
      FLAG=0
      for j in `kubectl --namespace=${i} get pods | awk '{print $1":"$2":"$3":"$4}'`
      do
        CONTAINER=`echo ${j} | cut -f1 -d:`
        ACTIVE=`echo ${j} | cut -f2 -d: | cut -f1 -d/`
        EXPECTED=`echo ${j} | cut -f2 -d: | cut -f2 -d/`
        ERROR=`echo ${j} | cut -f3 -d:`
        DAYS=`echo ${j} | cut -f4 -d:`

        if [[ ${ACTIVE} -ne ${EXPECTED} ]]
        then
          if [[ ${FLAG} -eq 0 ]]
          then
            printf "%b\n" "    ${RED}Namespace ${i} is reporting errors:${RESET}" >> $LOG
            FLAG=1
          fi
          printf "%b\n" "      ${RED}Container ${CONTAINER} has failed. ${ACTIVE} of ${EXPECTED} containers are running. Reported error: ${ERROR}${RESET}" >> $LOG
        fi
      done
    done
  fi
  if [[ ${DEBUG} = '11' ]]
  then
    echo "Exiting check_kubernetes()"
  fi
}


######################
### Check to make sure logging is current (_something_ with today's date in the logs)
### Number of Checks: 1
######################

check_logs() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_logs(12)"
  fi
  CL_TODAY=`date +"%b %e"`

# default logfile for Solaris
  PLOG="/var/adm/messages"
  if [[ $OS = "Linux" ]]
  then
    PLOG="/var/log/messages"
  fi
  if [[ $OS = "FreeBSD" ]]
  then
    PLOG="/var/log/messages"
  fi
  if [[ $OS = "HP-UX" ]]
  then
    PLOG="/var/adm/syslog/syslog.log"
  fi

  printf "%b\n" "  ${GREEN}Checking ${PLOG} for ${CL_TODAY}.${RESET}" >> $LOG

  OUTPUT=`tail -1 ${PLOG} | grep "^${CL_TODAY}"`
  if [[ -z $OUTPUT ]]
  then
    printf "%b\n" "    ${RED}${PLOG} has no log entries for today.${RESET}" >> $LOG
  fi
  if [[ ${DEBUG} = '12' ]]
  then
    echo "Exiting check_logs()"
  fi
}


######################
### Check for deleted items indicating a lost log file typically
### Number of Checks: 1
######################

check_lsof() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_lsof(13)"
  fi
  which lsof
  if [[ $? = 0 ]]
  then
    OUTPUT=`lsof | grep "(deleted)" | wc -l`
    if [[ $OUTPUT -gt 0 ]]
    then
      printf "%b\n" "  ${RED}lsof is reporting ${OUTPUT} deleted processes.${RESET}" >> $LOG
    fi
  fi
  if [[ ${DEBUG} = '13' ]]
  then
    echo "Exiting check_lsof()"
  fi
}


######################
### Check the system memory
### Number of Checks: 2
######################

check_memory() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering Memory check"
  fi

  if [[ ${OS} = 'Linux' ]]
  then
# in kb
    MEMORY=`awk '/MemTotal/{print $2}' /proc/meminfo`
    COUNT=$(( $MEMORY / 1024 / 1024 + 1 ))
  fi

  if [[ ${OS} = 'SunOS' ]]
  then
# in mb
    MEMORY=`prtconf | awk '/Memory/{print $3}'`
    COUNT=$(( $MEMORY / 1024 + 1 ))
  fi

  if [[ ${OS} = 'HP-UX' ]]
  then
# in mb
    MEMORY=`machinfo | awk '/Memory:/{print $2}/Memory =/{print $3}'`
#    if [[ -z ${MEMORY} ]]
#    then
#      MEMORY=`machinfo | grep "Memory =" | awk '{print $3}'`
#    fi
    COUNT=$(( $MEMORY / 1024 + 1 ))
  fi

  APPROVED=`grep -i "^${HOSTNAME}:Memory:${COUNT}" ${INTRADO}/etc/chkserver.exclude`
# if blank, then we didn't find an approved value, continue with the check
  if [[ "${APPROVED}" = "" ]]
  then
    if [[ $COUNT -ne $FIELD3 ]]
    then
      printf "%b\n" "  ${RED}System shows ${COUNT}G where expected is ${FIELD3}G${RESET}" >> $LOG
    else
      printf "%b\n" "  ${GREEN}${COUNT}G of Memory as expected${RESET}" >> $LOG
    fi
  else
    printf "%b\n" "  ${GREEN}${COUNT}G of Memory as approved${RESET}" >> $LOG
  fi
}


######################
### Check the status of Netbackup
### Number of Checks: 10
######################

check_netbackup() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_netbackup(14)"
  fi
  if [[ -f /usr/openv/netbackup/bp.conf ]]
  then
    printf "%b\n" "  ${GREEN}NetBackup is installed${RESET}" >> $LOG
# netbackup versino 7 doesn't use hosts.allow any more.
    if [[ -f /usr/openv/netbackup/bin/version ]]
    then
      VERSION=`awk '{print $2}' /usr/openv/netbackup/bin/version | cut -f1 -d.`
# if 6, check for hosts.allow
# if 7, no need to check; warning if it exists?      
      if [[ ${VERSION} = 6 ]]
      then
        if [[ ! -f /etc/hosts.allow ]]
        then
          printf "%b\n" "    ${RED}/etc/hosts.allow is missing${RESET}" >> $LOG
        else
# look for bpcd, bpjava-msvc, vnetd, and vopied.
          for nb in bpcd bpjava-msvc vnetd vopied
          do
            grep "^${nb}:" /etc/hosts.allow > /dev/null
            if [[ ! $? = 0 ]]
            then
              printf "%b\n" "    ${RED}${nb} is missing from /etc/hosts.allow${RESET}" >> $LOG
            fi
            if [[ ${nb} = "vnetd" ]]
            then
              BUSERVERS="${BUSERVERS} ${BUEXTRA}"
            fi
            for nbip in ${BUSERVERS}
            do
              grep "^${nb}:" /etc/hosts.allow | egrep "(:|,| )${nbip}( |,|$)" > /dev/null
              if [[ ! $? = 0 ]]
              then
                printf "%b\n" "    ${RED}${nbip} is missing from the ${nb} line in /etc/hosts.allow${RESET}" >> $LOG
              fi
            done
          done
        fi
      fi
    fi  

    for NBLIST in ${BUIPLIST}
    do
      check_management_route ${NBLIST}
    done

# 13724 is vnetd
    NBLIST=`netstat -an | grep LISTEN | grep 13724`
    if [[ -z $NBLIST ]]
    then
      printf "%b\n" "    ${RED}NetBackup vnetd is not running${RESET}" >> $LOG
    else
      printf "%b\n" "    ${GREEN}NetBackup vnetd is running${RESET}" >> $LOG
    fi
# 13782 is bpcd
    NBLIST=`netstat -an | grep LISTEN | egrep 13782`
    if [[ -z $NBLIST ]]
    then
      printf "%b\n" "    ${RED}NetBackup bpcd is not running${RESET}" >> $LOG
    else
      printf "%b\n" "    ${GREEN}NetBackup bpcd is running${RESET}" >> $LOG
    fi

# check for access to the two backup servers
    for NBLIST in ${NBSERVERS}
    do
      if [[ ! -z ${NETCAT} ]]
      then
        echo "" | ${NETCAT} -w 2 -vn ${NBLIST} 1556 > /dev/null 2>&1
        if [[ $? = 0 ]]
        then
          printf "%b\n" "    ${GREEN}${NBLIST}:1556 is accessible${RESET}" >> $LOG
        else
          printf "%b\n" "    ${RED}${NBLIST}:1556 is not accessible${RESET}" >> $LOG
        fi
        echo "" | ${NETCAT} -w 2 -vn ${NBLIST} 13724 > /dev/null 2>&1
        if [[ $? = 0 ]]
        then
          printf "%b\n" "    ${GREEN}${NBLIST}:13724 is accessible${RESET}" >> $LOG
        else
          printf "%b\n" "    ${RED}${NBLIST}:13724 is not accessible${RESET}" >> $LOG
        fi
      fi
    done

# check for last backup
#Backed Up         Expires       Files      KB     C Sched Type      Policy
#----------------  ---------- -------- ----------- - --------------- ------------
#07/15/2017 12:00  07/29/2017   138984    15491642 N Full Backup     BRHM_ECR_Servers

    if [[ -f  $INTRADO/etc/backups.output ]]
    then
      if [[ ! -s $INTRADO/etc/backups.output ]]
      then
        printf "%b\n" "    ${RED}${INTRADO}/etc/backups.output is empty.${RESET} Verify the servername in /usr/openv/netbackup/bp.conf" >> $LOG
      else
        OUTPUT=`awk '/Backed Up/{next}/------------/{next}{print $1;exit}' ${INTRADO}/etc/backups.output`
        if [[ $OS = 'Linux' ]]
        then
          BUDATE=`date --date=$OUTPUT +"%s"`
        else
          BUYEAR=`echo $OUTPUT | cut -f3 -d/`
          BUMONTH=`echo $OUTPUT | cut -f2 -d/`
          BUDAY=`echo $OUTPUT | cut -f1 -d/`
          BUDATE=`epoch $BUYEAR $BUMONTH $BUDAY`
        fi
        EXPIRED=$(( $BUDATE + $SEVEN ))
        if [[ ${EPOCH} -gt ${EXPIRED} ]]
        then
          printf "%b\n" "    ${RED}Last backup was more than 7 days ago (${OUTPUT})${RESET}" >> $LOG
        else
          printf "%b\n" "    ${GREEN}Last backup was ${OUTPUT}${RESET}" >> $LOG
        fi
      fi
    fi
  fi
  if [[ ${DEBUG} = '14' ]]
  then
    echo "Exiting check_netbackup()"
  fi
}


######################
### Check the status of Nagios Remote Plugin Executor
### Number of Checks: 2
######################

check_nrpe() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_nrpe(15)"
  fi
  if [[ -f /usr/sbin/nrpe ]]
  then
    printf "%b\n" "  ${GREEN}The NRPE agent is installed${RESET}" >> $LOG
    NAGIOS=`ps -e | grep nrpe`
    if [[ -z $NAGIOS ]]
    then
      printf "%b\n" "    ${RED}The NRPE agent is not running${RESET}" >> $LOG
    else
      printf "%b\n" "    ${GREEN}The NRPE agent is running${RESET}" >> $LOG
    fi
  fi
  if [[ ${DEBUG} = '15' ]]
  then
    echo "Exiting check_nrpe()"
  fi
}


######################
### Check to see if there are any out of memory killer messages (oom-killer)
### Number of Checks: 1
######################

check_oomkiller() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_oomkiller(34)"
  fi
  printf "%b\n" "  ${GREEN}Checking for out-of-memory errors${RESET}" >> $LOG
  grep "invoked oom-killer" ${PLOG} > /dev/null
  if [[ $? = 0 ]]
  then
    printf "%b\n" "    ${RED}Found oom-killer messages in ${PLOG}${RESET}" >> $LOG
  fi
  if [[ ${DEBUG} = '34' ]]
  then
    echo "Exiting check_oomkiller()"
  fi
}


######################
### Check the status of Openview
### Number of Checks: 9
######################

check_openview() {
# if Openview was found, check to see if it's running
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_openview(16)"
  else
    if [[ ${DEBUG} = 16 ]]
    then
      set -x
    fi
  fi
  if [[ -d /opt/OV/bin ]]
  then
    printf "%b\n" "  ${GREEN}OpenView agent is installed${RESET}" >> $LOG
    OPENVIEW=`ps -e | grep ovcd`
    if [[ -z $OPENVIEW ]]
    then
      printf "%b\n" "    ${RED}OpenView agent is not running${RESET}" >> $LOG
    else
      ABORT=`/opt/OV/bin/opcagt -status | grep -ci abort`
      RUNNING=`/opt/OV/bin/opcagt -status | grep -ci running`
      STOPPED=`/opt/OV/bin/opcagt -status | grep -ci stopped`
      STARTING=`/opt/OV/bin/opcagt -status | grep -ci starting`
      if [[ ${ABORT} = 0 ]] && [[ ${RUNNING} -gt 0 ]]
      then
        printf "%b\n" "    ${GREEN}Openview agent is running: Stopped: ${STOPPED} Starting: ${STARTING} Running: ${RUNNING}${RESET}" >> $LOG
      else
        printf "%b\n" "    ${RED}Openview agent is running: Aborted: ${ABORT} Stopped: ${STOPPED} Starting: ${STARTING} Running: ${RUNNING}${RESET}" >> $LOG
      fi

      for i in ${MONSERVERS}
      do
        OVNAME=`echo $i | cut -f1 -d:`
        OVIP=`echo $i | cut -f2 -d:`

        check_management_route ${OVIP}

        ping ${OVIP} ${PINGCT} > /dev/null
        if [[ $? = 0 ]]
        then
          printf "%b\n" "    ${GREEN}${OVNAME} Openview VIP is pingable${RESET}" >> $LOG
          if [[ ! -z ${NETCAT} ]]
          then
# netcat isn't working correctly everywhere but it is working in some places...
            echo "  nc check of ${OVNAME} Openview Server"
            echo "" | ${NETCAT} -w 2 -vn ${OVIP} 383 > /dev/null 2>&1
            if [[ $? = 0 ]]
            then
              printf "%b\n" "    ${GREEN}${OVNAME} VIP is accessible${RESET}" >> $LOG
            else
              printf "%b\n" "    ${RED}${OVNAME} VIP is not accessible${RESET}" >> $LOG
            fi
          fi

# since we're here, check the Openview Ping tool too
          /opt/OV/bin/bbcutil -ping ${OVIP} > /dev/null
          if [[ $? = 0 ]]
          then
            printf "%b\n" "    ${GREEN}bbcutil is able to ping ${OVNAME}${RESET}" >> $LOG
          else
            printf "%b\n" "    ${RED}bbcutil is unable to ping ${OVNAME}${RESET} /opt/OV/bin/bbcutil -ping ${OVIP}" >> $LOG
          fi
        else
          printf "%b\n" "    ${RED}${OVNAME} Openview VIP is not pingable${RESET}" >> $LOG
        fi
      done

      CERTLIST=`/opt/OV/bin/ovcert -list | egrep -vc "(Keystore|Certificates|\+|^$)"`
      CERTS=`/opt/OV/bin/ovcert -status`
      if [[ ${CERTS} = 'Status: Certificate is installed.' ]]
      then
        printf "%b\n" "    ${GREEN}Certificates (${CERTLIST}) are installed${RESET}" >> $LOG
      else
        if [[ ${CERTS} = 'Status: Undefined (Certificate Client could not be contacted).' ]]
        then
          printf "%b\n" "    ${RED}Unable to contact Certificate Client. ${CERTLIST} Certificates installed${RESET} /opt/OV/bin/ovcert -list" >> $LOG
        else
          if [[ ${CERTS} = 'Status: Certificate request is pending.' ]]
          then
            printf "%b\n" "    ${YELLOW}Certificate request is pending.${RESET} /opt/OV/bin/ovcert -list" >> $LOG
          else
            if [[ ${CERTS} = 'Status: Certificate request was denied.' ]]
            then
              printf "%b\n" "    ${RED}Certificate request was denied.${RESET} /opt/OV/bin/ovcert -list" >> $LOG
            else
              printf "%b\n" "    ${RED}Uncaught error: ${CERTS}${RESET}" >> $LOG
            fi
          fi
        fi
      fi

      BUFFERING=`/opt/OV/bin/opcagt -status | grep -i buffering`
      if [[ ${BUFFERING} = 'Message Agent is buffering.' ]]
      then
        printf "%b\n" "    ${RED}Openview agent is buffering${RESET}" >> $LOG
      fi

# check the configuration for Openview.
# the chkserver.input file should have entries identifying 
# the ip and management bits
      EXPECTED_IP=`grep "^${HOSTNAME}:IPAddressMonitored:" ${INTRADO}/etc/chkserver.input | cut -f3 -d:`
      EXPECTED_INTERFACE=`grep "^${HOSTNAME}:InterfaceMonitored:" ${INTRADO}/etc/chkserver.input | cut -f3 -d:`
      EXPECTED_MONITOR=`grep "^${HOSTNAME}:MonitoringServer:" ${INTRADO}/etc/chkserver.input | cut -f3 -d:`

      if [[ ${DEBUG} = 16 ]]
      then
        echo "IP:${EXPECTED_IP}, Interface:${EXPECTED_INTERFACE}, Monitor:${EXPECTED_MONITOR}"
      fi

      if [[ ${EXPECTED_IP} = '' ]]
      then
        printf "%b\n" "    ${RED}Unable to locate ${HOSTNAME} in chkserver.input file to verify Openview Configuration${RESET}" >> $LOG
      else
# now check the configuration
        RESULT=`/opt/OV/bin/ovconfget bbc.cb SERVER_BIND_ADDR`
        if [[ ! ${EXPECTED_IP} = ${RESULT} ]]
        then
          printf "%b\n" "    ${RED}Configuration: bbc.cb SERVER_BIND_ADDR=${RESULT} is not ${EXPECTED_IP}${RESET}" >> $LOG
        fi
        RESULT=`/opt/OV/bin/ovconfget bbc.http SERVER_BIND_ADDR`
        if [[ ! ${EXPECTED_IP} = ${RESULT} ]]
        then
          printf "%b\n" "    ${RED}Configuration: bbc.http SERVER_BIND_ADDR=${RESULT} is not ${EXPECTED_IP}${RESET}" >> $LOG
        fi
        RESULT=`/opt/OV/bin/ovconfget bbc.http CLIENT_BIND_ADDR`
        if [[ ! ${EXPECTED_IP} = ${RESULT} ]]
        then
          printf "%b\n" "    ${RED}Configuration: bbc.http CLIENT_BIND_ADDR=${RESULT} is not ${EXPECTED_IP}${RESET}" >> $LOG
        fi
        RESULT=`/opt/OV/bin/ovconfget eaagt OPC_IP_ADDRESS`
        if [[ ! ${EXPECTED_IP} = ${RESULT} ]]
        then
          printf "%b\n" "    ${RED}Configuration: eaagt OPC_IP_ADDRESS=${RESULT} is not ${EXPECTED_IP}${RESET}" >> $LOG
        fi
        RESULT=`/opt/OV/bin/ovconfget eaagt OPC_MGMT_SERVER`
        if [[ ! ${EXPECTED_MONITOR} = ${RESULT} ]]
        then
          printf "%b\n" "    ${RED}Configuration: eaagt OPC_MGMT_SERVER=${RESULT} is not ${EXPECTED_MONITOR}${RESET}" >> $LOG
        fi
        RESULT=`/opt/OV/bin/ovconfget eaagt OPC_PRIMARY_MGR`
        if [[ ! ${EXPECTED_MONITOR} = ${RESULT} ]]
        then
          printf "%b\n" "    ${RED}Configuration: eaagt OPC_PRIMARY_MGR=${RESULT} is not ${EXPECTED_MONITOR}${RESET}" >> $LOG
        fi
        RESULT=`/opt/OV/bin/ovconfget sec.cm.client CERTIFICATE_SERVER`
        if [[ ! ${EXPECTED_MONITOR} = ${RESULT} ]]
        then
          printf "%b\n" "    ${RED}Configuration: sec.cm.client CERTIFICATE_SERVER=${RESULT} is not ${EXPECTED_MONITOR}${RESET}" >> $LOG
        fi
        RESULT=`/opt/OV/bin/ovconfget sec.core.auth MANAGER`
        if [[ ! ${EXPECTED_MONITOR} = ${RESULT} ]]
        then
          printf "%b\n" "    ${RED}Configuration: sec.core.auth MANAGER=${RESULT} is not ${EXPECTED_MONITOR}${RESET}" >> $LOG
        fi
      fi

    fi
  fi
  if [[ ${DEBUG} = '16' ]]
  then
    echo "Exiting check_openview()"
    unset -x
  fi
}


######################
### Check Opnet if found
### Number of Checks: 6
######################

check_opnet() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_opnet(17)"
  fi
  if [[ -d /opt/Panorama ]]
  then
    printf "%b\n" "  ${GREEN}OpNet is installed${RESET}" >> $LOG
# Panorama starts as /bin/sh /opt/Panorama/....
    APPI=`ps -ef | grep "/opt/Panorama/"`
    if [[ ! -z $APPI ]]
    then
      printf "%b\n" "    ${GREEN}OpNet is running${RESET}" >> $LOG
    else
      printf "%b\n" "    ${YELLOW}OpNet is not running${RESET}" >> $LOG
    fi
    if [[ $OS = 'Linux' ]]
    then
      OUTPUT=`chkconfig --list appinternals | grep ":on"`
      if [[ -z $OUTPUT ]]
      then
        printf "%b\n" "    ${YELLOW}OpNet is not configured to start on boot${RESET}" >> $LOG
      else
        printf "%b\n" "    ${GREEN}OpNet is configured to start on boot${RESET}" >> $LOG
      fi
    fi
    if [[ ! -z ${NETCAT} ]]
    then
      for j in ${OPNETSERVERS}
      do
        OPNETIP=`echo $j | cut -f1 -d:`
        OPNETPORT=`echo $j | cut -f2 -d:`

# looking for a skip entry in the chkserver.exclude file
        APPROVED=`grep -i "^${HOSTNAME}:OpNet:${OPNETIP}" ${INTRADO}/etc/chkserver.exclude`
        if [[ "${APPROVED}" = "" ]]
        then
          echo "  nc check of OpNet Server"
          echo "quit" | ${NETCAT} -w 2 -vn ${OPNETIP} ${OPNETPORT} > /dev/null 2>&1
          if [[ $? = 0 ]]
          then
            printf "%b\n" "    ${GREEN}OpNet Server (${OPNETIP}:${OPNETPORT}) is accessible${RESET}" >> $LOG
          else
            printf "%b\n" "    ${YELLOW}OpNet Server (${OPNETIP}:${OPNETPORT}) is not accessible${RESET}" >> $LOG
          fi
        else
          printf "%b\n" "    ${GREEN}OpNet Server (${OPNETIP}:${OPNETPORT}) check was skipped.${RESET}" >> $LOG
        fi
      done
    fi
  fi 
  if [[ ${DEBUG} = '17' ]]
  then
    echo "Exiting check_opnet()"
  fi
}


######################
### Check to see if users who have privileged access have expired or shouldn't have it
### Number of Checks: 2 * [Number of users on the system]
######################

check_privileged_access() {
# see if the user is in the chksudoers.dat file. This indicates the user has privileged access.
# check for * for sysadmins who should be on every server
# error if the user is not in the chksudo.dat file.
# error if the date is older than the expiration date.
#lnmt1cuomrcs1:cschelin:Carl Schelin,carl.schelin@intrado.com:yes:Expired
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_privileged_access(18)"
  fi
  if [[ -f $INTRADO/etc/chksudo.dat ]]
  then
    printf "%b\n" "  ${GREEN}Privileged access review${RESET}" >> $LOG
    for j in `awk -F: '{print $1":"$2":"$4}' $INTRADO/etc/chksudoers.output`
    do
      SERVER=`echo $j | cut -f1 -d:`
      USER=`echo $j | cut -f2 -d:`
      ROOT=`echo $j | cut -f3 -d:`

      if [[ ${ROOT} = 'yes' ]]
      then
        OUTPUT=`grep "^\*:${USER}:" $INTRADO/etc/chksudo.dat`
        if [[ -z $OUTPUT ]]
        then
          OUTPUT=`grep "^${SERVER}:${USER}:" $INTRADO/etc/chksudo.dat`
          if [[ -z $OUTPUT ]]
          then
            printf "%b\n" "    ${RED}${USER} has undocumented privileged access${RESET}" >> $LOG
          fi
        fi

        if [[ ! -z $OUTPUT ]]
        then
# only need the date
#wkkihiecerb21:escott:999999:30010101
          EXPIREDATE=`echo $OUTPUT | cut -f4 -d:`
          if [[ $OS = 'Linux' ]]
          then
            EXPIRE=`date --date="${EXPIREDATE}" +"%s"`
          else
            EXYEAR=`echo $EXPIREDATE | cut -c1-4`
            EXMONTH=`echo $EXPIREDATE | cut -c5-6`
            EXDAY=`echo $EXPIREDATE | cut -c7-8`
            EXPIRE=`epoch $EXYEAR $EXMONTH $EXDAY`
          fi
          if [[ ${EPOCH} -gt ${EXPIRE} ]]
          then
            printf "%b\n" "    ${RED}${USER} has privileged access which expired: ${EXPIREDATE}${RESET}" >> $LOG
          fi
        fi
      fi
    done
  fi
  if [[ ${DEBUG} = '18' ]]
  then
    echo "Exiting check_privileged_access()"
  fi
}


######################
### Check the status of subscriptions for Red Hat servers only (so not an OS check)
### Number of Checks: 1
######################

check_redhat_subscription() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_redhat_subscription(19)"
  fi
  if [[ -f /etc/redhat-release ]]
  then
    if [[ ${DEBUG} = '19' ]]
    then
      echo "  Red Hat System"
    fi
    for i in ${SATELLITESERVERS}
    do
      printf "%b\n" "  ${GREEN}Checking access to Satellite Server ${i}${RESET}" >> $LOG
      check_management_route ${i}
      echo "  ping check of Red Hat Satellite Server: ${i}"
      ping ${i} ${PINGCT} > /dev/null
      if [[ $? = 0 ]]
      then
        printf "%b\n" "    ${GREEN}Satellite Server ${i} is pingable${RESET}" >> $LOG
      else
        printf "%b\n" "    ${RED}Satellite Server ${i} is not pingable${RESET}" >> $LOG
      fi

      echo "  nc check of Satellite Server ports"
      for j in 80 443 5646 5647 5671 5672 8140 9090 
      do
        echo "quit" | ${NETCAT} -w 2 -vn ${i} ${j} > /dev/null 2>&1
        if [[ $? = 0 ]]
        then
          printf "%b\n" "    ${GREEN}Satellite Server (${i}:${j}) is accessible${RESET}" >> $LOG
        else
          printf "%b\n" "    ${RED}Satellite Server (${i}:${j}) is not accessible${RESET}" >> $LOG
        fi
      done
    done

    if [[ ! -f /usr/bin/subscription-manager ]]
    then
      printf "%b\n" "  ${RED}Subscription-Manager not installed${RESET}" >> $LOG
    else
      if [[ ${DEBUG} = '19' ]]
      then
        echo "  Subscription Manager is installed, query server"
      fi

      printf "%b\n" "    ${GREEN}Subscription-Manager is installed${RESET}" >> $LOG

      STATUS=`/usr/bin/subscription-manager list | awk '/^Status:/{print $2}'`
      if [[ ${DEBUG} = '19' ]]
      then
        echo "  Returned status: ${STATUS}"
      fi
      if [[ ${STATUS} = 'Unknown' ]]
      then
        printf "%b\n" "      ${RED}System is not subscribed to Satellite${RESET}" >> $LOG
      fi
      if [[ ${STATUS} = 'No' ]]
      then
        printf "%b\n" "      ${RED}System is not subscribed to Satellite${RESET}" >> $LOG
      fi
      if [[ ${STATUS} = 'Subscribed' ]]
      then
        printf "%b\n" "      ${GREEN}System is subscribed to Satellite${RESET}" >> $LOG
      fi
      if [[ ${STATUS} = 'Expired' ]]
      then
        printf "%b\n" "      ${YELLOW}System subscription has expired${RESET}" >> $LOG
      fi

      if [[ ${STATUS} = 'Subscribed' ]] || [[ ${STATUS} = 'Expired' ]]
      then
        RPM=`rpm -qa | grep 'katello-ca-consumer-lnmtcodcstl10'`
        if [[ -z ${RPM} ]]
        then
          printf "%b\n" "      ${RED}Katello Certificate RPM is not installed${RESET} rpm -qa | grep katello-ca" >> $LOG
        fi
        RPM=`rpm -qa | grep 'katello-agent'`
        if [[ -z ${RPM} ]]
        then
          printf "%b\n" "      ${RED}Katello Agent RPM is not installed${RESET} rpm -qa | grep katello-agent" >> $LOG
        fi
      fi

    fi
  fi
  if [[ ${DEBUG} = '19' ]]
  then
    echo "Exiting check_redhat_subscription()"
  fi
}


######################
### Check the status of RemoveIPS on Red Hat systems
### Number of Checks: 2
######################

check_removeips() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_removeips(20)"
  fi
  if [[ -f /etc/redhat-release ]]
  then
# removeips=yes is causing a problem with non-system accounts. best is to just disable it on server.
# if without comments it's yes, report an error
# if blank and with comments it's yes, report an error
    if [[ -f /etc/systemd/logind.conf ]]
    then
# get the answer
      OUTPUT=`grep -v "^#" /etc/systemd/logind.conf | grep removeipc | cut -f2 -d=`
      if [[ $OUTPUT = 'yes' ]]
      then
        printf "%b\n" "  ${RED}Change RemoveIPC to no in /etc/systemd/logind.conf${RESET} systemctl restart systemd-logind.service" >> $LOG
      fi
      if [[ -z $OUTPUT ]]
      then
        OUTPUT=`grep -i removeipc /etc/systemd/logind.conf | cut -f2 -d=`
        if [[ $OUTPUT = 'yes' ]]
        then
          printf "%b\n" "  ${RED}Set RemoveIPC to no in /etc/systemd/logind.conf${RESET} systemctl restart systemd-logind.service" >> $LOG
        fi
      fi
    fi
  fi
  if [[ ${DEBUG} = '20' ]]
  then
    echo "Exiting check_removeips()"
  fi
}


######################
### Check the resolv.conf nameserver entries
### Number of Checks: 2 * [Number of nameserver entries] + 1
######################

check_resolver() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_resolver(21)"
  fi
  if [[ -f /etc/nsswitch.conf ]]
  then
    OUTPUT=`grep -i ^hosts: /etc/nsswitch.conf | grep -i dns`
    if [[ -z $OUTPUT ]]
    then
      printf "%b\n" "  ${GREEN}Name services in /etc/nsswitch.conf not enabled${RESET}" >> $LOG
    else
      if [[ -f /etc/resolv.conf ]]
      then
        COUNT=`grep -v "^#" /etc/resolv.conf | grep -c nameserver`
        if [[ $COUNT = 0 ]]
        then
          printf "%b\n" "  ${RED}No nameserver entries found in /etc/resolv.conf${RESET}" >> $LOG
        else
          for i in `awk '/^[^#]?nameserver/{print $2}' /etc/resolv.conf`
          do
            printf "%b\n" "  ${GREEN}Found nameserver ${i} in /etc/resolv.conf${RESET}" >> $LOG
            check_management_route ${i}
            echo "  ping check of nameserver: ${i}"
            ping ${i} ${PINGCT} > /dev/null
            if [[ $? = 0 ]]
            then
              printf "%b\n" "    ${GREEN}Nameserver ${i} pingable${RESET}" >> $LOG
            else
              printf "%b\n" "    ${RED}Nameserver ${i} is not pingable${RESET}" >> $LOG
            fi
            for j in ${MGTLISTING}
            do
              MGTSVR=`echo $j | cut -f1 -d:`
              MGTIP=`echo $j | cut -f2 -d:`

              OUTPUT=`dig @${i} +time=1 ${MGTSVR} | grep -v "^;" | grep "${MGTIP}"`
              if [[ -z $OUTPUT ]]
              then
                printf "%b\n" "    ${RED}Unable to resolve ${MGTSVR}${RESET}" >> $LOG
              else
              printf "%b\n" "    ${GREEN}Resolved ${MGTSVR}${RESET}" >> $LOG
              fi
            done
          done
        fi
        if [[ $COUNT -gt 3 ]]
        then
          printf "%b\n" "  ${RED}More than 3 nameserver entries found in /etc/resolv.conf${RESET}" >> $LOG
        fi
      fi
    fi
  fi
  if [[ ${DEBUG} = '21' ]]
  then
    echo "Exiting check_resolver()"
  fi
}


######################
### Check the status of the routing tables
### Number of Checks: 1
######################

check_routetable() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_routetable(22)"
  fi
  if [[ ! -f $INTRADO/etc/routetable.output ]]
  then
    $INTRADO/bin/chkroutetable
  fi
  if [[ -s $INTRADO/etc/routetable.output ]]
  then
    printf "%b\n" "  ${RED}Route table mismatch.${RESET}" >> $LOG
    cat $INTRADO/etc/routetable.output >> $LOG
    echo -en "${RESET}" >> $LOG
  fi
  if [[ ${DEBUG} = '22' ]]
  then
    echo "Exiting check_routetable()"
  fi
}


######################
### Check the status of rrdtool; should be running on Linux and Sun systems
### Number of Checks: 1
######################

check_rrdtool() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_rrdtool(23)"
  fi
  if [[ $OS = "Linux" ]] || [[ $OS = "SunOS" ]]
  then
    UPDATERRD=`ps -ef | grep updaterrd`
    if [[ -z $UPDATERRD ]]
    then
      printf "%b\n" "  ${YELLOW}rrdtool is not configured or running${RESET}" >> $LOG
    fi
  fi
  if [[ ${DEBUG} = '23' ]]
  then
    echo "Exiting check_rrdtool()"
  fi
}


######################
### Check remote root access via ssh
### Number of Checks: 1
######################

check_security() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_security()"
  fi
  if [[ -f ${INTRADO}/etc/chksecurity.output ]]
  then
    SECURITY=`cat ${INTRADO}/etc/chksecurity.output | awk '{print $NF}'`
    if [[ ${SECURITY} = 'yes' ]]
    then
      printf "%b\n" "  ${RED}Remote root access via ssh is permitted${RESET}" >> $LOG
    fi
  fi
  if [[ ${DEBUG} = '23' ]]
  then
    echo "Exiting check_security()"
  fi
}


######################
### Check the status of selinux. Should be disabled. If enabled, permissive is warning, enforcing is error
### Number of Checks: 1
######################

check_selinux() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_selinux(29)"
  fi
  if [[ ${OS} = 'Linux' ]]
  then
    if [[ ${DEBUG} = '29' ]]
    then
      echo ""
    fi
    printf "%b\n" "  ${GREEN}Checking selinux status${RESET}" >> $LOG
    SESTATUS=`sestatus | awk '/status/ {print $3}'`
    if [[ ${SESTATUS} = 'enabled' ]]
    then
      ENABLED=`sestatus | awk '/Current mode:/ {print $3}'`
      if [[ ${ENABLED} = 'enforcing' ]]
      then
        printf "%b\n" "    ${RED}selinux is in Enforcing mode${RESET}" >> $LOG
      fi
      if [[ ${ENABLED} = 'permissive' ]]
      then
        printf "%b\n" "    ${YELLOW}selinux is in Permissive mode${RESET}" >> $LOG
      fi
    else
      printf "%b\n" "    ${GREEN}selinux is Disabled${RESET}" >> $LOG
    fi
  fi
  if [[ ${DEBUG} = '29' ]]
  then
    echo "Exiting check_selinux()"
  fi
}


######################
### Check the sudoers file
### Number of Checks: 3
######################

check_sudoers() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_sudoers(24)"
  fi
  if [[ -f ${SUDOERS} ]]
  then
    if [[ ${DEBUG} = '24' ]]
    then
      echo "  Found ${SUDOERS}"
    fi
    grep -i ${HOSTNAME} ${SUDOERS} > /dev/null
    if [[ $? = 1 ]]
    then
      printf "%b\n" "  ${YELLOW}${SUDOERS} doesn't contain ${HOSTNAME} alias${RESET}" >> $LOG
    fi

# now check to make sure groups in sudoers are present.
    if [[ ${DEBUG} = '24' ]]
    then
      echo "  Checking groups are a real group."
    fi
    for i in `awk '/^%/{sub(/%/,"",$1);print $1}' ${SUDOERS}`
    do
      if [[ ${OS} = 'HP-UX' ]] || [[ ${OS} = 'FreeBSD' ]]
      then
        if [[ ${DEBUG} = '24' ]]
        then
          OUTPUT=`grep "^${i}:" /etc/group`
          echo "    Checking ^${i}: in /etc/group. Found: ${OUTPUT}"
        fi
        grep "^${i}:" /etc/group > /dev/null
        if [[ $? -eq 1 ]]
        then
          printf "%b\n" "  ${RED}sudoers group ${i} doesn't exist in /etc/group${RESET}" >> $LOG
        fi
      else
        if [[ ${DEBUG} = '24' ]]
        then
          OUTPUT=`getent group ${i}`
          echo "    Checking for ^${i}:. Found: ${OUTPUT}"
        fi
        getent group ${i} > /dev/null
        if [[ $? -ne 0 ]]
        then
          printf "%b\n" "  ${RED}sudoers group ${i} doesn't exist${RESET}" >> $LOG
        fi
      fi
    done

  else
    printf "%b\n" "  ${RED}sudoers file not found${RESET}" >> $LOG
  fi

  if [[ ${DEBUG} = '24' ]]
  then
    echo "Exiting check_sudoers()"
  fi
}


######################
### Check to make sure swap is appropriatly sized
### Number of Checks: 3
### For Red Hat:
### Swap >= Ram up to 8G
### Swap >= 8 Ram over 8G
######################

check_swap() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_swap(25)"
  fi
  APPROVED=`grep -i "^${HOSTNAME}:Swap" ${INTRADO}/etc/chkserver.exclude | cut -f3 -d:`
  if [[ $OS = 'Linux' ]]
  then
    if [[ -f /usr/sbin/lvdisplay ]]
    then
      SWAP=`awk '/swap/{print $1}' /etc/fstab`
      SIZE=`lvdisplay ${SWAP} | awk '/LV Size/{print $3}'`
      TOTAL=`awk '/MemTotal/{print $2}' /proc/meminfo`
      MEMORY=$(( ${TOTAL} / 1024 / 1024 + 1 ))

      if [[ ${DEBUG} = '25' ]]
      then
        echo "  Values, Swap: ${SWAP}, Size: ${SIZE}, Total: ${TOTAL}, Memory: ${MEMORY}"
      fi

# try this with free instead
      SWAP=`free | awk '/Swap/{print $2}'`
      ADDED=`echo "${SWAP} / 1024 / 1024" | bc`
      SIZE=`echo "(${SWAP} / 1024 + ${ADDED}) / 1024" | bc`

      if [[ ${DEBUG} = '25' ]]
      then
        echo "  Values, Swap: ${SWAP}, Size: ${SIZE}, Total: ${TOTAL}, Memory: ${MEMORY}"
      fi

#if memory <= 8 and swap < memory then error
#if memory >= 8 and swap < 8 then error

      if [[ ! -z ${APPROVED} ]] && [[ ${SIZE} -eq ${APPROVED} ]]
      then
        printf "%b\n" "  ${GREEN}Swap is correct at ${SIZE} Gig.${RESET}" >> $LOG
      else
        if [[ ${MEMORY} -gt 8 ]] && [[ ${SIZE} -lt 8 ]]
        then
          printf "%b\n" "  ${YELLOW}Memory is ${MEMORY} Gig but Swap is ${SIZE} Gig.${RESET}" >> $LOG
        else
          if [[ ${MEMORY} -le 8 ]] && [[ ${SIZE} -lt ${MEMORY} ]]
          then
            printf "%b\n" "  ${YELLOW}Swap is ${SIZE} Gig which is less than Memory which is ${MEMORY} Gig.${RESET}" >> $LOG
          fi
        fi
      fi
    fi
  fi
  if [[ ${DEBUG} = '25' ]]
  then
    echo "Exiting check_swap()"
  fi
}


######################
### Check to see if the /opt/techops[70] directory exists
### Number of Checks: 2
######################

check_techops() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_techops(30)"
  fi
  if [[ -d /opt/techops ]]
  then
    printf "%b\n" "  ${YELLOW}The /opt/techops directory still exists${RESET}" >> $LOG
  fi

  if [[ -d /opt/techops70 ]]
  then
    printf "%b\n" "  ${YELLOW}The /opt/techops70 directory still exists${RESET}" >> $LOG
  fi

  if [[ ${DEBUG} = '30' ]]
  then
    echo "Exiting check_techops()"
  fi
}


######################
### Check the time sources
### Number of Checks: 6
######################

check_time() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_time(26)"
  fi
  printf "%b\n" "  ${GREEN}Checking time synchronization.${RESET}" >> $LOG
  T_MSG=''
  T_COMMAND=''
  T_CONFIG=''
  T_RUNNING=''
# if chrony is running (Red Hat 7 mostly)
  if [[ -f /bin/chronyc ]]
  then
    T_MSG='chrony'
    T_COMMAND='/bin/chronyc -n sources'
    T_CONFIG='/etc/chrony.conf'
    T_RUNNING=`ps -e | grep chronyd`
  fi

# everything else; Sun and older Red Hat
  if [[ -f /usr/sbin/ntpq ]]
  then
    T_MSG='ntp'
    T_COMMAND='/usr/sbin/ntpq -pn'
    if [[ $OS = 'SunOS' ]]
    then
      T_CONFIG='/etc/inet/ntp.conf'
    else
      T_CONFIG='/etc/ntp.conf'
    fi
    T_RUNNING=`ps -ef | egrep "(xntpd|ntpd)"`
  fi

# is it installed?
  if [[ ! -z ${T_MSG} ]]
  then
    printf "%b\n" "    ${GREEN}Checking ${T_MSG} time server.${RESET}" >> $LOG
    if [[ ! -z ${T_RUNNING} ]]
    then
      printf "%b\n" "    ${GREEN}Time server is running.${RESET}" >> $LOG
      printf "%b\n" "    ${GREEN}Checking ${T_MSG} time sources.${RESET}" >> $LOG

      for i in $GPSSERVERS
      do
        check_management_route ${i}
        echo "  ping check of time server: ${i}"
        ping ${i} ${PINGCT} > /dev/null
        if [[ $? = 0 ]]
        then
          printf "%b\n" "      ${GREEN}GPS Server ${i} is pingable.${RESET}" >> $LOG
        else
          printf "%b\n" "      ${RED}GPS Server ${i} is not pingable.${RESET}" >> $LOG
        fi
        OUTPUT=`grep -v "^#" ${T_CONFIG} | grep ${i}`
        if [[ -z $OUTPUT ]]
        then
          printf "%b\n" "      ${RED}GPS Server ${i} is not in the ${T_CONFIG} configuration file.${RESET}" >> $LOG
        else
          echo "  time check of time server: ${i}"
          ntpdate -q ${i} > /dev/null
          if [[ $? = 0 ]]
          then
            printf "%b\n" "      ${GREEN}GPS Server ${i} is providing time.${RESET}" >> $LOG
          else
            printf "%b\n" "      ${RED}GPS Server ${i}:UDP/123 is not reachable.${RESET} ntpdate -q ${i} failed" >> $LOG
          fi

# Updated NTP check - validates ticker status as well as reachability
# The modified T_COMMAND/awk pipelines now return a string with only "<status> <reachability>" for the provided IP
          if [[ $T_MSG = 'chrony' ]]
          then
            OUTPUT=`${T_COMMAND} | awk /${i}/'{print substr($1,2,1),$5}'`
          fi
          if [[ $T_MSG = 'ntp' ]]
          then
            OUTPUT=`${T_COMMAND} | awk /${i}/'{print substr($1,1,1),$7}'`
          fi
# Then these ksh constructs split out the status and reachability values without a fork/exec subshell by
# trimming a prefix/suffix from the combined string using built-in parameter expansion
          REACH="${OUTPUT##* }"
          STATUS="${OUTPUT%% *}"
          if [[ -z ${REACH} ]]
          then
            printf "%b\n" "      ${RED}Unable to determine Reachability for GPS Server ${i}.${RESET}" >> $LOG
          else
# Reachability should always be 377 - anything else is a problem of some kind, regardless of status.
            if [[ $REACH = '377' ]]
            then
# But even if reachability is 377, status must be '*' or '+' also or there's a different kind of problem.
              if [[ $STATUS = '*' ]] || [[ $STATUS = '+' ]]
              then
                printf "%b\n" "      ${GREEN}GPS Server ${i} Reachability and Status (${REACH}/${STATUS}) are good.${RESET}" >> $LOG
              else
                printf "%b\n" "      ${RED}GPS Server ${i} Reachability is good, but Status (${STATUS}) is not.${RESET}" >> $LOG
              fi
            else
              printf "%b\n" "      ${RED}GPS Server ${i} Reachability (${REACH}) is not 377. Status is ${STATUS}.${RESET}" >> $LOG
            fi
          fi
        fi
      done

      DRIFTFILE=`awk '/^[^#]?driftfile/{df=$2}END{print df}' ${T_CONFIG}`
      DRIFTPATH=`dirname $DRIFTFILE`
      if [[ -d ${DRIFTPATH} ]]
      then
        if [[ ! -f ${DRIFTFILE} ]]
        then
          printf "%b\n" "      ${YELLOW}${T_MSG} drift file (${DRIFTFILE}) does not exist.${RESET}" >> $LOG
        fi
      else
        printf "%b\n" "      ${RED}${T_MSG} drift file path (${DRIFTPATH}) does not exist.${RESET}" >> $LOG
      fi
    else
      printf "%b\n" "    ${RED}Time servers is not running.${RESET}" >> $LOG
    fi
  else
    printf "%b\n" "    ${RED}No time servers installed.${RESET}" >> $LOG
  fi
  if [[ ${DEBUG} = '26' ]]
  then
    echo "Exiting check_time()"
  fi
}


######################
### Check the vmware agent
### Number of Checks: 2
######################

# check ethernet addresses. if 00:50:56, then it's a VMWare vm
# linux would be 00:50:56
# solaris would be 0:50:56
# hpux would be 0x005056

check_vmware_agent() {
  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering check_vmware_agent(27)"
  fi
  if [[ $OS = 'HP-UX' ]]
  then
    OUTPUT=`lanscan | grep " 0x005056"`
  else
    if [[ $OS = 'Linux' ]]
    then
      OUTPUT=`ip addr | grep ether | grep " 00:50:56"`
    else
      OUTPUT=`ifconfig -a | grep ether | grep " 0:50:56"`
    fi
  fi
  if [[ ! -z $OUTPUT ]]
  then
    if [[ -f /usr/bin/vmtoolsd ]] || [[ -f /usr/sbin/vmtoolsd ]]
    then
      printf "%b\n" "  ${GREEN}VMWare Agent is installed${RESET}" >> $LOG
      VMWARE=`ps -e | grep vmtoolsd`
      if [[ -z $VMWARE ]]
      then
        printf "%b\n" "    ${YELLOW}VMWare Agent is not running${RESET}" >> $LOG
      else
        printf "%b\n" "    ${GREEN}VMWare Agent is running${RESET}" >> $LOG
      fi
    else
      printf "%b\n" "  ${YELLOW}VMWare Agent is not installed${RESET}" >> $LOG
    fi
# check the status of ctrl-alt-del service
    if [[ ${OS} = 'Linux' ]]
    then
      if [[ ${OSMAJOR} = '7' ]]
      then
        OUTPUT=`systemctl status ctrl-alt-del.target | grep "Loaded: masked"`
        if [[ -z ${OUTPUT} ]]
        then
          printf "%b\n" "  ${RED}Ctrl-Alt-Del target is not masked${RESET} systemctl status ctrl-alt-del.target" >> $LOG
        fi
      fi
      if [[ ${OSMAJOR} = '6' ]]
      then
        OUTPUT=`egrep "^(start|exec)" /etc/init/control-alt-delete.conf`
        if [[ ! -z ${OUTPUT} ]]
        then
          printf "%b\n" "  ${RED}Ctrl-Alt-Del target is enabled${RESET} egrep '^(start|exec)' /etc/init/control-alt-delete.conf" >> $LOG
        fi
      fi
      if [[ ${OSMAJOR} = '5' ]]
      then
        OUTPUT=`grep "^ca::ctrlaltdel" /etc/inittab"`
        if [[ ! -z ${OUTPUT} ]]
        then
          printf "%b\n" "  ${RED}Ctrl-Alt-Del is enabled${RESET} grep '^ca::ctrlaltdel' /etc/inittab" >> $LOG
        fi
      fi
    fi
  fi
  if [[ ${DEBUG} = '27' ]]
  then
    echo "Exiting check_vmware_agent()"
  fi
}

######################
### End of Functions
######################



echo "" > $LOG
echo "================================" >> $LOG
echo "Running System Validation Script" >> $LOG
echo $VERSION >> $LOG
echo "================================" >> $LOG
echo "" >> $LOG

printf "%b\n" "${GREEN}Passed${RESET} - Test or value was successful" >> $LOG
printf "%b\n" "${YELLOW}Warning${RESET} - Setting should be reviewed and corrected if appropriate" >> $LOG
printf "%b\n" "${RED}Error${RESET} - Must be corrected due to vulnerability or system stability issue" >> $LOG
echo "" >> $LOG

echo "Note:"
echo "  Ping checks have a count of 1"
echo "  Netcat (nc) checks have a wait of 2"
echo "  ./chkserver debug [number] displays more messages for that function"
echo ""


###########
### Linux
### Red Hat
###########

if [[ $OS = "Linux" ]]
then
  if [[ `id -u` -ne 0 ]]
  then
    printf "%b" "${RED}Due to the checks, this script must be run by root.${RESET}\n"
    exit 0
  fi
fi

###########
### HP-UX
###########

if [[ $OS = "HP-UX" ]]
then
  if [[ `id -u` -ne 0 ]]
  then
    printf "%b\n" "${RED}Due to the checks, this script must be run by root.${RESET}"
    exit 0
  fi
fi

###########
### Solaris
### SunOS
###########

if [[ $OS = "SunOS" ]]
then
  if [[ `id | cut -f2 -d= | cut -f1 -d\(` -ne 0 ]]
  then
    printf "%b\n" "${RED}Due to the checks, this script must be run by root.${RESET}"
    exit 0
  fi
fi



##########
### Start the check
##########

echo ${VERSION}

check_hostname

check_sudoers

check_selinux

check_resolver

check_routetable

check_time

check_email

check_jumpstart

check_redhat_subscription

check_interfaces

check_swap

check_techops

check_logs

check_centrify

check_group_membership

check_default_passwords

check_security

check_privileged_access

check_active_employees

check_kubernetes

# disable as it's really not helping; lots of deleted files on all systems.
#check_lsof

check_disk_suite

check_disk_space

check_oomkiller

check_vmware_agent

check_rrdtool

check_cfg2html

check_intrado

check_ksh

check_removeips

#####
# Check the status of installed agents
#####

check_openview

check_netbackup

check_data_palette

check_opnet

check_nrpe

# these checks are pulled from the auto-generated chkserver.input file.
if [[ -f /opt/intrado/etc/chkserver.input ]]
then

  if [[ ! ${DEBUG} = 'no' ]]
  then
    echo "Entering chkserver.input check"
  fi

  for j in `egrep "^(${HOSTNAME}|\*):" /opt/intrado/etc/chkserver.input`
  do

    FIELD2=`echo $j | cut -f2 -d:`
    FIELD3=`echo $j | cut -f3 -d:`
    FIELD4=`echo $j | cut -f4 -d:`

    if [[ $FIELD2 = 'CPU' ]]
    then
      check_cpus
    fi
    
    if [[ $FIELD2 = 'Memory' ]]
    then
      check_memory
    fi
    
    if [[ $FIELD2 = 'IP' ]]
    then
      check_addresses
    fi

    if [[ $FIELD2 = 'Service' ]]
    then
      if [[ ! ${DEBUG} = 'no' ]]
      then
        echo "Entering Service check"
      fi
      grep "^${FIELD3}:" /etc/passwd > /dev/null
      if [[ $? = 0 ]]
      then
        printf "%b\n" "  ${GREEN}Service Account ${FIELD3} exists${RESET}" >> $LOG


        if [[ $OS = 'Linux' ]]
        then
          PASSWORD=`chage -l ${FIELD3} | egrep -i "password expires.*never"`
          if [[ ! -z ${PASSWORD} ]]
          then
            printf "%b\n" "    ${GREEN}Password doesn't expire${RESET}" >> $LOG
          else
            PASSWORD=`chage -l ${FIELD3} | egrep -i "password expires.*changed"`
            if [[ ! -z ${PASSWORD} ]]
            then
              printf "%b\n" "    ${RED}Password must be changed${RESET}" >> $LOG
            else
              printf "%b\n" "    ${RED}Password expires${RESET} chage -E -1 -M -1 -I -1 ${FIELD3}" >> $LOG
            fi
          fi
          ACCOUNT=`chage -l ${FIELD3} | egrep -i "account expires.*never"`
          if [[ ! -z $ACCOUNT ]]
          then
            printf "%b\n" "    ${GREEN}Account doesn't expire${RESET}" >> $LOG
          else
            printf "%b\n" "    ${RED}Account expires${RESET} chage -E -1 -M -1 -I -1 ${FIELD3}" >> $LOG
          fi
        fi

        if [[ $OS = 'HP-UX' ]]
        then
          PASSWORD=`passwd -s ${FIELD3} | awk '{print $5}'`
          if [[ $PASSWORD = '0' ]] || [[ -z $PASSWORD ]]
          then
            printf "%b\n" "    ${GREEN}Password doesn't expire${RESET}" >> $LOG
          else
            if [[ $PASSWORD = 'password must be changed' ]]
            then
              printf "%b\n" "    ${RED}Password expires date/message: ${PASSWORD}${RESET} You must change the service account password: ${FIELD3}" >> $LOG
            else
# if a trusted system:
# /usr/lbin/modprpw -l -m mintm=0,exptm=0 username
              if [[ -f "/tcb/files/auth/system/default" ]]
              then
                printf "%b\n" "    ${RED}Password expires date/message: ${PASSWORD}${RESET} /usr/lbin/modprpw -l -m mintm=0,exptm=0 ${FIELD3}" >> $LOG
              else
                printf "%b\n" "    ${RED}Password expires date/message: ${PASSWORD}${RESET} passwd -x -1 ${FIELD3}" >> $LOG
              fi
            fi
          fi
        fi

        if [[ $OS = 'SunOS' ]]
        then
          PASSWORD=`grep "^${FIELD3}:" /etc/shadow | cut -f5 -d:`
          if [[ $PASSWORD = '' ]]
          then
            printf "%b\n" "    ${GREEN}Password doesn't expire${RESET}" >> $LOG
          else
            PASSWORD=`passwd -s | awk '{print $3}'`
            if [[ $PASSWORD = '00/00/00' ]]
            then
              printf "%b\n" "    ${RED}Password has not been changed since the account was created and has expired.${RESET} passwd -x -1 ${FIELD3}" >> $LOG
            else
              printf "%b\n" "    ${RED}Password expires${RESET} passwd -x -1 ${FIELD3}" >> $LOG
            fi
          fi
        fi

        if [[ $OS = 'FreeBSD' ]]
        then
          PASSWORD=`grep "^${FIELD3}:" /etc/master.passwd | cut -f5 -d:`
          if [[ $PASSWORD = '' ]]
          then
            printf "%b\n" "    ${GREEN}Password doesn't expire${RESET}" >> $LOG
          else
            PASSWORD=`passwd -s | awk '{print $3}'`
            if [[ $PASSWORD = '00/00/00' ]]
            then
              printf "%b\n" "    ${RED}Password has not been changed since the account was created and has expired.${RESET} passwd -x -1 ${FIELD3}" >> $LOG
            else
              printf "%b\n" "    ${RED}Password expires${RESET} passwd -x -1 ${FIELD3}" >> $LOG
            fi
          fi
        fi

      else
        printf "%b\n" "  ${RED}Unable to locate ${FIELD3} in /etc/passwd${RESET}" >> $LOG
      fi

# special checks for special accounts.
      if [[ ${FIELD3} = 'nginx' ]]
      then
        grep -i 640 /etc/logrotate.d/nginx > /dev/null
        if [[ $? = 0 ]]
        then
          printf "%b\n" "    ${RED}Update /etc/logrotate.d/nginx create permissions to 644.${RESET} vi /etc/logrotate.d/nginx" >> $LOG
        fi
        grep -i nginx ${SUDOERS} > /dev/null
        if [[ $? = 1 ]]
        then
          printf "%b\n" "    ${RED}Update sudoers to add the Web Apps nginx rule.${RESET}" >> $LOG
        fi
        ls -l /var/log/nginx/* | head -1 | grep "^-rw-r-----" > /dev/null
        if [[ $? = 0 ]]
        then
          printf "%b\n" "    ${RED}Change the permissions of /var/log/nginx to 644.${RESET} chmod 644 /var/log/nginx/*" >> $LOG
        fi
      fi
    fi
    
    if [[ $FIELD2 = 'Group' ]]
    then
      if [[ ! ${DEBUG} = 'no' ]]
      then
        echo "Entering Group check"
      fi
      if [[ $OS = 'HP-UX' ]] || [[ $OS = 'FreeBSD' ]]
      then
        grep "^${FIELD3}:" /etc/group > /dev/null
      else
        getent group ${FIELD3} > /dev/null
      fi
      if [[ $? -eq 0 ]]
      then
        printf "%b\n" "  ${GREEN}Group ${FIELD3} exists${RESET}" >> $LOG
      else
        printf "%b\n" "  ${RED}Unable to locate ${FIELD3} group${RESET}" >> $LOG
      fi
    fi
    
    if [[ $FIELD2 = 'Sudoers' ]]
    then
      if [[ ! ${DEBUG} = 'no' ]]
      then
        echo "Entering Sudoers check"
      fi
      if [[ ! -z ${SUDOERS} ]]
      then
        grep "^%${FIELD3}" ${SUDOERS} > /dev/null
        if [[ $? = 0 ]]
        then
          printf "%b\n" "  ${GREEN}Sudoers group %${FIELD3} exists${RESET}" >> $LOG
        else
          printf "%b\n" "  ${YELLOW}Unable to locate %${FIELD3} in ${SUDOERS}${RESET}" >> $LOG
        fi
      else
        printf "%b\n" "  ${YELLOW}Unable to locate sudoers file.${RESET}" >> $LOG
      fi
    fi

# it's supposed to be installed, let's check
    if [[ $FIELD2 = 'Openview' ]]
    then
      if [[ ! ${DEBUG} = 'no' ]]
      then
        echo "Entering Openview check"
      fi
      if [[ ! -d /opt/OV/bin ]]
      then
        printf "%b\n" "  ${RED}OpenView is not installed${RESET}" >> $LOG
      fi
    fi

# it's supposed to be installed, let's check
    if [[ $FIELD2 = 'Netbackup' ]]
    then
      if [[ ! ${DEBUG} = 'no' ]]
      then
        echo "Entering Netbackup check"
      fi
      if [[ ! -f /usr/openv/netbackup/bp.conf ]]
      then
        printf "%b\n" "  ${RED}NetBackup is not installed${RESET}" >> $LOG
      fi
    fi

# it's supposed to be installed, let's check
    if [[ $FIELD2 = 'Datapalette' ]]
    then
      if [[ ! ${DEBUG} = 'no' ]]
      then
        echo "Entering Datapalette check"
      fi
      if [[ ! -f /opt/datapalette/bin/datapal ]]
      then
        printf "%b\n" "  ${RED}Data Palette is not installed${RESET}" >> $LOG
      fi
    fi

# it's supposed to be installed, let's check
    if [[ $FIELD2 = 'OpNet' ]]
    then
      if [[ ! ${DEBUG} = 'no' ]]
      then
        echo "Entering Opnet check"
      fi
      if [[ ! -d /opt/Panorama ]]
      then
        printf "%b\n" "  ${RED}OpNet is not installed${RESET}" >> $LOG
      fi
    fi

# it's supposed to be installed, let's check
    if [[ $FIELD2 = 'Centrify' ]]
    then
      if [[ ! ${DEBUG} = 'no' ]]
      then
        echo "Entering Centrify check"
      fi
      if [[ ! -f /usr/sbin/adclient ]]
      then
        printf "%b\n" "  ${RED}Centrify is not installed${RESET}" >> $LOG
      fi
    fi

# check to see if an account is supposed to be allowed to use cron
    if [[ $FIELD2 = 'Cron' ]]
    then
# if cron.allow exists, cron.deny is ignored
      if [[ -f ${CRONALLOW} ]]
      then
        grep -i ${FIELD3} ${CRONALLOW} > /dev/null
        if [[ $? = 1 ]]
        then
          printf "%b\n" "  ${RED}${FIELD3} is not allowed to use cron${RESET} Add ${FIELD3} to ${CRONALLOW}" >> $LOG
        fi
      else
        if [[ -f ${CRONDENY} ]]
        then
          grep -i ${FIELD3} ${CRONDENY} > /dev/null
          if [[ $? = 0 ]]
          then
            printf "%b\n" "  ${RED}${FIELD3} is not allowed to use cron${RESET} Remove ${FIELD3} from ${CRONDENY}" >> $LOG
          fi
        fi
      fi
    fi

  done

# if gateway has been found (eg there are IP entries)
  if [[ ! -z ${GATEWAY} ]]
  then
    printf "%b\n" "  ${GREEN}Default gateway entry found${RESET}" >> $LOG
    if [[ ${GWFLAG} = 'yes' ]]
    then
      if [[ ! -z ${GWMSG} ]]
      then
        printf "%b\n" "$GWMSG" >> $LOG
      fi
    else
      printf "%b\n" "    ${RED}None of the configured interface gateways were found in /etc/sysconfig/network${RESET}" >> $LOG
    fi
  fi

else 
  printf "%b\n" "${RED}chkserver.input file not found${RESET}" >> $LOG
fi


echo "" >> $LOG
echo "External steps to be performed:" >> $LOG
echo "" >> $LOG
echo "1. Check service processor password" >> $LOG
echo "2. Have the unixsvc account ssh to this system to make sure it all works." >> $LOG
echo "3. Have the unixsvc account copy the cfghtml file: $HOSTNAME.html to the jumpstart server" >> $LOG

if [[ ! -z $1 ]]
then
  cat $LOG
fi

