#!/bin/bash

# mysql.backup - 
#  1. Dump the mysql databases
#  2. Note changes with yesterday's databases
#  3. Archive the directory
#  4. Delete yesterday's directory
#  5. E-mail report if there are changes

# to verify database integrity:
#for i in *.MYI
#do
#  myisamchk $i
#  if [[ $? -gt 0 ]]
#  then
#    echo $i
#  fi
#done

# set up variables
ROOT="/var/tmp/mysql"
DATE=`date +"%Y%m%d"`
LOG="$ROOT/mysql.$DATE/mysql.report"
HTDOCS=/var/www/htdocs
HTSECURE=/var/www/htsecure
HTML=/var/www/html
HOSTNAME=`hostname | cut -f1 -d.`
WHOCARES="carl.schelin@intrado.com"
PATH="/usr/local/bin:/opt/csw/mysql5/bin:$PATH"; export PATH
# some servers the mysqldump command to dump individual files isn't working. This lets us still get backups but not the individual ones we normally get.
SETTAB="Yes"

chown -R mysql:mysql ${ROOT}
chmod -R 775 ${ROOT}

if [[ ${HOSTNAME} = "incojs01" ]]
then
  DATABASES="information_schema calendar crmprod inventory msglog mysql phpmyadmin reports repository"
  USER=root
  PASSWORD="this4now!!"
  OWNER="mysql:mysql"
  ARCHIVE=7
fi

if [[ ${HOSTNAME} = "lnmt1cuomtool10" ]] || [[ ${HOSTNAME} = "miam1cuomtool10" ]]
then
  DATABASES="information_schema inventory mysql performance_schema"
  USER=root
  PASSWORD="53Rv!c3!"
  OWNER="mysql:mysql"
  ARCHIVE=7
fi

# parsing the database names through the localsettings.php file
if [[ ${HOSTNAME} = "lnmt1cuaswiki1" ]] || [[ ${HOSTNAME} = "miam1cuaswiki1" ]]
then
  DATABASES=" information_schema mysql"

  for i in `ls -la ${HTML} | grep "^d" | awk '{print $9}'`
  do
    if [[ -f ${HTML}/${i}/LocalSettings.php ]]
    then
      DBNAME=`grep wgDBname ${HTML}/${i}/LocalSettings.php | awk -F\" '{print $2}'`

      echo "${DATABASES}" | grep " ${DBNAME} " > /dev/null
      if [[ $? -eq 1 ]]
      then
        DATABASES="${DATABASES} ${DBNAME}"
        echo "Found Unique Database, adding: ${DBNAME}"
      else
        echo "Found Duplicate Database, skipping: ${DBNAME}"
      fi
    fi
  done

  USER=root
  PASSWORD="this4now!!"
  OWNER="mysql:mysql"
  ARCHIVE=7
fi


if [[ -z ${DATABASES} ]]
then
  echo "Not on a supported mysql server. Exiting..."
  exit 0
fi


# remove current file if it exists. The idea being you can kick off another backup of the database at any time.
if [[ -f ${ROOT}/mysql.${DATE}.tar.gz ]]
then
  rm ${ROOT}/mysql.${DATE}.tar.gz
fi

# create new directory for backups
if [[ ! -d ${ROOT}/mysql.${DATE} ]]
then
  mkdir ${ROOT}/mysql.${DATE}
fi

# ensure mysql can actually write to the directory
chmod 775 ${ROOT}/mysql.${DATE}
chown ${OWNER} ${ROOT}/mysql.${DATE}


# dump the databases out
echo "Beginning mysql report: ${DATE}" > ${LOG}


for i in ${DATABASES}
do
# create new database directory for backups. don't dump a database if it's already there
  if [[ ! -d ${ROOT}/mysql.${DATE}/${i} ]]
  then
    TABVAR=""
    if [[ ${SETTAB} = 'Yes' ]]
    then
      TABVAR="--tab=${ROOT}/mysql.${DATE}/${i}/"
    fi

    mkdir -p ${ROOT}/mysql.${DATE}/${i}

# ensure mysql can actually write to the database directory
    chmod -R 775 ${ROOT}/mysql.${DATE}
    chown -R mysql:mysql ${ROOT}/mysql.${DATE}

    cd ${ROOT}/mysql.${DATE}/${i}

    echo "Dumping ${i}" >> ${LOG}
    echo "Dumping ${i}"
    echo "mysqldump ${TABVAR} --opt ${i} --user=\"${USER}\" --password=\"${PASSWORD}\""
    mysqldump ${TABVAR} --opt ${i} --user="${USER}" --password="${PASSWORD}" >> ${LOG}
  fi

done

# tar and compress today's files so it can be backed up to the remote server
if [[ -d ${ROOT}/mysql.${DATE} ]]
then
  cd ${ROOT}
  echo "Archive directory."
  tar cf mysql.${DATE}.tar mysql.${DATE}
  if [[ $? -eq 0 ]]
  then
    echo "Compress Archive."
    gzip -9 mysql.${DATE}.tar
    if [[ $? -eq 0 ]]
    then
      echo "Remove directory."
      rm -rf mysql.${DATE}
    fi
  fi
fi

# finally, remove all old backups
echo "Remove old compressed archives."
find ${ROOT} -name mysql.\*.gz -prune -atime +${ARCHIVE} -exec rm {} \;

exit 0

